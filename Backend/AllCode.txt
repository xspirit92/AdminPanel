
================================================================================
FILE: C:\Git\CubArt\CubArt.Api\Program.cs
================================================================================

using CubArt.Api.Middleware;
using CubArt.Application;
using CubArt.Infrastructure;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services
    .AddApplicationLayer()           // Application ????
    .AddInfrastructureLayer(builder.Configuration);  // Infrastructure ????;

builder.Services.AddControllers();

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Secret"]))
        };
    });


builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new Microsoft.OpenApi.OpenApiInfo
    {
        Title = "CubArt API",
        Version = "v1",
        Description = "API ??? ??????? ?????????? ????????????? CubArt"
    });
});


var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

// ? Production ?????? ???????????? ??? UI
if (app.Environment.IsProduction())
{
    app.UseSwagger();
}


// Middleware
app.UseMiddleware<ExceptionHandlingMiddleware>();
app.UseMiddleware<RequestLoggingMiddleware>();

app.UseHttpsRedirection();

app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();

app.Run();

================================================================================
FILE: C:\Git\CubArt\CubArt.Api\Attributes\RequirePermissionAttribute.cs
================================================================================

using CubArt.Domain.Enums;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc.Filters;
using Microsoft.AspNetCore.Mvc;
using CubArt.Application.Common.Services;

namespace CubArt.Api.Attributes
{
    public class RequirePermissionAttribute : AuthorizeAttribute, IAuthorizationFilter
    {
        private readonly PermissionEnum _permission;

        public RequirePermissionAttribute(PermissionEnum permission)
        {
            _permission = permission;
            Policy = "PermissionPolicy";
        }

        public void OnAuthorization(AuthorizationFilterContext context)
        {
            var authService = context.HttpContext.RequestServices.GetService<IAuthService>();
            if (authService == null)
            {
                context.Result = new ForbidResult();
                return;
            }

            var hasPermission = authService.HasPermissionAsync(_permission).GetAwaiter().GetResult();
            if (!hasPermission)
            {
                context.Result = new ForbidResult();
            }
        }
    }

    public class RequireAnyPermissionAttribute : AuthorizeAttribute, IAuthorizationFilter
    {
        private readonly PermissionEnum[] _permissions;

        public RequireAnyPermissionAttribute(params PermissionEnum[] permissions)
        {
            _permissions = permissions;
            Policy = "PermissionPolicy";
        }

        public void OnAuthorization(AuthorizationFilterContext context)
        {
            var authService = context.HttpContext.RequestServices.GetService<IAuthService>();
            if (authService == null)
            {
                context.Result = new ForbidResult();
                return;
            }

            var hasAnyPermission = authService.HasAnyPermissionAsync(_permissions).GetAwaiter().GetResult();
            if (!hasAnyPermission)
            {
                context.Result = new ForbidResult();
            }
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Api\Controllers\AuthController.cs
================================================================================

using CubArt.Application.Users.Commands;
using CubArt.Application.Users.DTOs;
using MediatR;
using Microsoft.AspNetCore.Mvc;

namespace CubArt.Api.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class AuthController : ControllerBase
    {
        private readonly IMediator _mediator;

        public AuthController(IMediator mediator)
        {
            _mediator = mediator;
        }

        [HttpPost("login")]
        [ProducesResponseType(typeof(LoginDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> Login([FromBody] LoginCommand request, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(request, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Api\Controllers\PaymentController.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Payments.Commands;
using CubArt.Application.Payments.DTOs;
using CubArt.Application.Payments.Queries;
using MediatR;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace CubArt.Api.Controllers
{
    [ApiController]
    [Authorize]
    [Route("api/[controller]")]
    public class PaymentController : ControllerBase
    {
        private readonly IMediator _mediator;

        public PaymentController(IMediator mediator)
        {
            _mediator = mediator;
        }

        [HttpGet]
        [ProducesResponseType(typeof(PagedListDto<PaymentDto>), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> GetPayments([FromQuery] GetAllPaymentsQuery query, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(query, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }

        [HttpGet("{id:guid}")]
        [ProducesResponseType(typeof(PaymentDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 404)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> GetPaymentById(Guid id, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(new GetPaymentByIdQuery(id), cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }

        [HttpPost]
        [ProducesResponseType(typeof(PaymentDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> CreateOrUpdatePayment([FromBody] CreateOrUpdatePaymentCommand command, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(command, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }

        [HttpDelete("{id:guid}")]
        [ProducesResponseType(typeof(PaymentDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 404)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> DeletePaymentById(Guid id, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(new DeletePaymentByIdCommand()
            { 
                Id = id
            }, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Api\Controllers\ProductController.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Products.Commands;
using CubArt.Application.Products.DTOs;
using CubArt.Application.Products.Queries;
using MediatR;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace CubArt.Api.Controllers
{
    [ApiController]
    [Authorize]
    [Route("api/[controller]")]
    public class ProductController : ControllerBase
    {
        private readonly IMediator _mediator;

        public ProductController(IMediator mediator)
        {
            _mediator = mediator;
        }

        [HttpGet]
        [ProducesResponseType(typeof(PagedListDto<ProductDto>), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> GetProducts([FromQuery] GetAllProductsQuery query, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(query, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }

        [HttpGet("{id:int}")]
        [ProducesResponseType(typeof(ProductDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 404)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> GetProductById(int id, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(new GetProductByIdQuery(id), cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }

        [HttpPost]
        [ProducesResponseType(typeof(ProductDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> CreateOrUpdateProduct([FromBody] CreateOrUpdateProductCommand command, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(command, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Api\Controllers\ProductionController.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Productions.Commands;
using CubArt.Application.Productions.DTOs;
using CubArt.Application.Productions.Queries;
using MediatR;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace CubArt.Api.Controllers
{
    [ApiController]
    [Authorize]
    [Route("api/[controller]")]
    public class ProductionController : ControllerBase
    {
        private readonly IMediator _mediator;

        public ProductionController(IMediator mediator)
        {
            _mediator = mediator;
        }

        [HttpGet]
        [ProducesResponseType(typeof(PagedListDto<ProductionDto>), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> GetProductions([FromQuery] GetAllProductionsQuery query, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(query, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }

        [HttpGet("{id:guid}")]
        [ProducesResponseType(typeof(ProductionDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 404)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> GetProductionById(Guid id, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(new GetProductionByIdQuery(id), cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }

        [HttpPost]
        [ProducesResponseType(typeof(ProductionDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> CreateOrUpdateProduction([FromBody] CreateOrUpdateProductionCommand command, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(command, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }

        [HttpDelete("{id:guid}")]
        [ProducesResponseType(typeof(ProductionDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 404)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> DeleteProductionById(Guid id, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(new DeleteProductionByIdCommand()
            {
                Id = id
            }, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Api\Controllers\PurchaseController.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Purchases.Commands;
using CubArt.Application.Purchases.DTOs;
using MediatR;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace CubArt.Api.Controllers
{
    [ApiController]
    [Authorize]
    [Route("api/[controller]")]
    public class PurchaseController : ControllerBase
    {
        private readonly IMediator _mediator;

        public PurchaseController(IMediator mediator)
        {
            _mediator = mediator;
        }

        [HttpGet]
        [ProducesResponseType(typeof(PagedListDto<PurchaseDto>), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> GetPurchases([FromQuery] GetAllPurchasesQuery query, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(query, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }

        [HttpGet("{id:guid}")]
        [ProducesResponseType(typeof(PurchaseDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 404)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> GetPurchaseById(Guid id, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(new GetPurchaseByIdQuery(id), cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }

        [HttpPost]
        [ProducesResponseType(typeof(PurchaseDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> CreateOrUpdatePurchase([FromBody] CreateOrUpdatePurchaseCommand command, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(command, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }

        [HttpDelete("{id:guid}")]
        [ProducesResponseType(typeof(PurchaseDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 404)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> DeletePurchaseById(Guid id, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(new DeletePurchaseByIdCommand() 
            {
                Id = id
            }, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Api\Controllers\StockBalanceViewController.cs
================================================================================

using CubArt.Api.Attributes;
using CubArt.Application.Common.Models;
using CubArt.Application.StockBalances.DTOs;
using CubArt.Application.StockBalances.Queries;
using CubArt.Domain.Enums;
using MediatR;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace CubArt.Api.Controllers
{
    [ApiController]
    [Authorize]
    [Route("api/[controller]")]
    public class StockBalanceViewController : ControllerBase
    {
        private readonly IMediator _mediator;

        public StockBalanceViewController(IMediator mediator)
        {
            _mediator = mediator;
        }

        [HttpGet]
        [RequirePermission(PermissionEnum.StockRead)]
        [ProducesResponseType(typeof(PagedListDto<StockBalanceViewDto>), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> GetStockBalanceViews([FromQuery] GetAllStockBalanceViewsQuery query, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(query, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Api\Controllers\SupplyController.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Supplies.Commands;
using CubArt.Application.Supplies.DTOs;
using CubArt.Application.Supplies.Queries;
using MediatR;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace CubArt.Api.Controllers
{
    [ApiController]
    [Authorize]
    [Route("api/[controller]")]
    public class SupplyController : ControllerBase
    {
        private readonly IMediator _mediator;

        public SupplyController(IMediator mediator)
        {
            _mediator = mediator;
        }

        [HttpGet]
        [ProducesResponseType(typeof(PagedListDto<SupplyDto>), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> GetSupplies([FromQuery] GetAllSuppliesQuery query, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(query, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }

        [HttpGet("{id:guid}")]
        [ProducesResponseType(typeof(SupplyDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 404)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> GetSupplyById(Guid id, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(new GetSupplyByIdQuery(id), cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }

        [HttpPost]
        [ProducesResponseType(typeof(SupplyDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> CreateOrUpdateSupply([FromBody] CreateOrUpdateSupplyCommand command, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(command, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }

        [HttpDelete("{id:guid}")]
        [ProducesResponseType(typeof(SupplyDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 404)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> DeleteSupplyById(Guid id, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(new DeleteSupplyByIdCommand()
            { 
                Id = id
            }, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Api\Controllers\UserController.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Users.Commands;
using CubArt.Application.Users.DTOs;
using MediatR;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;

namespace CubArt.Api.Controllers
{
    [ApiController]
    [Authorize]
    [Route("api/[controller]")]
    public class UserController : ControllerBase
    {
        private readonly IMediator _mediator;

        public UserController(IMediator mediator)
        {
            _mediator = mediator;
        }

        [HttpPost("create-user")]
        [ProducesResponseType(typeof(UserDto), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> CreateUser([FromBody] CreateUserCommand request, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(request, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }

        [HttpPost("change-password")]
        [ProducesResponseType(typeof(Result), 200)]
        [ProducesResponseType(typeof(ProblemDetails), 400)]
        public async Task<IActionResult> ChangePassword([FromBody] ChangePasswordCommand request, CancellationToken cancellationToken)
        {
            var result = await _mediator.Send(request, cancellationToken);

            if (result.IsSuccess)
                return Ok(result);

            return BadRequest(result);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Api\Middleware\ExceptionHandlingMiddleware.cs
================================================================================

using CubArt.Domain.Exceptions;
using System.Text.Json;

namespace CubArt.Api.Middleware
{
    public class ExceptionHandlingMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<ExceptionHandlingMiddleware> _logger;
        private readonly IHostEnvironment _env;

        public ExceptionHandlingMiddleware(
            RequestDelegate next,
            ILogger<ExceptionHandlingMiddleware> logger,
            IHostEnvironment env)
        {
            _next = next;
            _logger = logger;
            _env = env;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            try
            {
                await _next(context);
            }
            catch (NotFoundException ex)
            {
                _logger.LogWarning(ex, "Объект не найден");
                await HandleExceptionAsync(context, ex, StatusCodes.Status404NotFound);
            }
            catch (DomainException ex)
            {
                _logger.LogWarning(ex, "Domain validation error");
                await HandleExceptionAsync(context, ex, StatusCodes.Status400BadRequest);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Непредвиденная ошибка");
                await HandleExceptionAsync(context, ex, StatusCodes.Status500InternalServerError);
            }
        }

        private static async Task HandleExceptionAsync(HttpContext context, Exception exception, int statusCode)
        {
            context.Response.ContentType = "application/json";
            context.Response.StatusCode = statusCode;

            // Собираем полную информацию об исключении
            var exceptionDetails = GetExceptionDetails(exception);

            var response = new
            {
                type = "https://tools.ietf.org/html/rfc7231#section-6.5.1",
                title = GetTitleForStatusCode(statusCode),
                status = statusCode,
                detail = exception.Message,
                instance = context.Request.Path.ToString(),
                errors = exceptionDetails.Errors,
                stackTrace = exceptionDetails.StackTrace,
                innerException = exceptionDetails.InnerException
            };

            var options = new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                WriteIndented = context.RequestServices.GetRequiredService<IHostEnvironment>().IsDevelopment()
            };

            var json = JsonSerializer.Serialize(response, options);
            await context.Response.WriteAsync(json);
        }

        private static (string[] Errors, string StackTrace, object InnerException) GetExceptionDetails(Exception exception)
        {
            var errors = new List<string> { exception.Message };
            var currentException = exception;

            // Собираем все внутренние исключения
            while (currentException.InnerException != null)
            {
                currentException = currentException.InnerException;
                errors.Add($"Inner: {currentException.Message}");
            }

            string stackTrace = null;
            object innerException = null;

            stackTrace = exception.StackTrace;

            if (exception.InnerException != null)
            {
                innerException = new
                {
                    message = exception.InnerException.Message,
                    type = exception.InnerException.GetType().Name,
                    stackTrace = exception.InnerException.StackTrace
                };
            }

            return (errors.ToArray(), stackTrace, innerException);
        }


        private static string GetTitleForStatusCode(int statusCode)
        {
            return statusCode switch
            {
                400 => "Bad Request",
                404 => "Not Found",
                500 => "Internal Server Error",
                _ => "An error occurred"
            };
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Api\Middleware\RequestLoggingMiddleware.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Interfaces;
using System.Diagnostics;
using System.Security.Claims;

namespace CubArt.Api.Middleware
{
    public class RequestLoggingMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<RequestLoggingMiddleware> _logger;

        public RequestLoggingMiddleware(
            RequestDelegate next,
            ILogger<RequestLoggingMiddleware> logger)
        {
            _next = next;
            _logger = logger;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            var sw = Stopwatch.StartNew();
            var originalBodyStream = context.Response.Body;

            using var responseBody = new MemoryStream();
            context.Response.Body = responseBody;

            // Получаем scoped сервисы через контекст
            var logRepository = context.RequestServices.GetRequiredService<ISystemLogRepository>();

            try
            {
                await _next(context);
                sw.Stop();

                await LogRequest(context, sw.ElapsedMilliseconds, null, logRepository);
            }
            catch (Exception ex)
            {
                sw.Stop();
                await LogRequest(context, sw.ElapsedMilliseconds, ex, logRepository);
                throw;
            }
            finally
            {
                responseBody.Seek(0, SeekOrigin.Begin);
                await responseBody.CopyToAsync(originalBodyStream);
            }
        }

        private async Task LogRequest(HttpContext context, long durationMs, Exception? ex, ISystemLogRepository logRepository)
        {
            try
            {
                string fullExceptionDetails = null;
                if (ex != null)
                {
                    fullExceptionDetails = ex.GetFullExceptionDetails();
                }

                var log = new SystemLog(
                    level: ex != null ? "Error" : "Information",
                    message: $"{context.Request.Method} {context.Request.Path} - {context.Response.StatusCode}",
                    userId: context.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value,
                    ipAddress: context.Connection.RemoteIpAddress?.ToString(),
                    userAgent: context.Request.Headers["User-Agent"].ToString(),
                    source: "API",
                    action: context.Request.Method,
                    additionalData: System.Text.Json.JsonSerializer.Serialize(new
                    {
                        DurationMs = durationMs,
                        StatusCode = context.Response.StatusCode,
                        QueryString = context.Request.QueryString.Value,
                        Path = context.Request.Path,
                        Method = context.Request.Method,
                        Exception = fullExceptionDetails // Добавляем полные детали исключения
                    }),
                    exceptionType: ex?.GetType().Name
                );

                await logRepository.AddAsync(log);
            }
            catch (Exception logEx)
            {
                _logger.LogError(logEx, "Ошибка при логировании запроса");
            }
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\DependencyInjection.cs
================================================================================

using AutoMapper;
using CubArt.Application.Common.BackgroundServices;
using CubArt.Application.Common.Behaviors;
using CubArt.Application.Common.Mapping;
using CubArt.Application.Common.Services;
using FluentValidation;
using MediatR;
using Microsoft.Extensions.DependencyInjection;
using System.Reflection;

namespace CubArt.Application
{
    public static class DependencyInjection
    {
        public static IServiceCollection AddApplicationLayer(this IServiceCollection services)
        {
            // MediatR
            services.AddMediatR(cfg =>
                cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly()));


            services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());

            // Behaviors
            services.AddScoped(typeof(IPipelineBehavior<,>), typeof(CachingBehavior<,>));
            services.AddScoped(typeof(IPipelineBehavior<,>), typeof(CacheInvalidationBehavior<,>));
            services.AddScoped(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));
            services.AddScoped(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));

            // Background services
            services.AddHostedService<StockBalanceRecalculationService>();

            // AutoMapper - явная регистрация
            services.AddSingleton<IMapper>(provider =>
            {
                //var loggerFactory = provider.GetRequiredService<ILoggerFactory>();

                var configuration = new MapperConfiguration(cfg =>
                {
                    cfg.AddProfile<MappingProfile>();
                });

                return configuration.CreateMapper();
            });

            // Services
            services.AddScoped<IAuthService, AuthService>();

            services.AddHttpContextAccessor();

            return services;
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Common\BackgroundServices\StockBalanceRecalculationService.cs
================================================================================

using Cronos;
using CubArt.Infrastructure.Interfaces;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace CubArt.Application.Common.BackgroundServices
{
    public class StockBalanceRecalculationService : BackgroundService
    {
        private readonly IServiceProvider _serviceProvider;
        private readonly ILogger<StockBalanceRecalculationService> _logger;

        public StockBalanceRecalculationService(
            IServiceProvider serviceProvider,
            ILogger<StockBalanceRecalculationService> logger)
        {
            _serviceProvider = serviceProvider;
            _logger = logger;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            try
            {
                using var scope = _serviceProvider.CreateScope();
                var stockMovementService = scope.ServiceProvider.GetRequiredService<IStockMovementService>();
                
                var date = await stockMovementService.GetLastBalanceDate();
                await stockMovementService.RecalculateAllBalancesFromDate(date, cancellationToken: stoppingToken);

                while (!stoppingToken.IsCancellationRequested)
                {
                    try
                    {
                        // Запускаем в 00:00 каждый день для расчета балансов за предыдущий день
                        await WaitForNextSchedule("0 21 * * *"); //utc

                        date = await stockMovementService.GetLastBalanceDate();
                        await stockMovementService.RecalculateAllBalancesFromDate(date, cancellationToken: stoppingToken);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Ошибка при пересчете балансов");
                        await Task.Delay(TimeSpan.FromHours(1), stoppingToken); // Повтор через час при ошибке
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Ошибка при пересчете балансов");
            }
        }
        private async Task WaitForNextSchedule(string cronExpression)
        {
            var parsedExp = CronExpression.Parse(cronExpression);
            var currentUtcTime = DateTimeOffset.UtcNow.UtcDateTime;
            var occurenceTime = parsedExp.GetNextOccurrence(currentUtcTime);

            var delay = occurenceTime.GetValueOrDefault() - currentUtcTime;
            var message = string.Format($"{nameof(StockBalanceRecalculationService)} запустится через {0:%d} дней {0:hh\\:mm\\:ss}", delay);
            

            await Task.Delay(delay);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Common\Behaviors\CacheInvalidationBehavior.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Products.Commands;
using CubArt.Infrastructure.Caching;
using MediatR;
using Microsoft.Extensions.Logging;

namespace CubArt.Application.Common.Behaviors
{
    public class CacheInvalidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
    where TResponse : Result
    {
        private readonly IRedisCacheService _cache;
        private readonly ILogger<CacheInvalidationBehavior<TRequest, TResponse>> _logger;

        public CacheInvalidationBehavior(
            IRedisCacheService cache,
            ILogger<CacheInvalidationBehavior<TRequest, TResponse>> logger)
        {
            _cache = cache;
            _logger = logger;
        }

        public async Task<TResponse> Handle(
            TRequest request,
            RequestHandlerDelegate<TResponse> next,
            CancellationToken cancellationToken)
        {
            var result = await next();

            // Инвалидируем кэш только после успешных Command
            if (result.IsSuccess && IsCommandRequest(request))
            {
                await InvalidateCache(request);
            }

            return result;
        }

        private static bool IsCommandRequest(TRequest request)
        {
            return request.GetType().Name.EndsWith("Command");
        }

        private async Task InvalidateCache(TRequest request)
        {
            try
            {
                switch (request)
                {
                    case CreateOrUpdateProductCommand command:
                        if (command.Id.HasValue)
                        {
                            await _cache.RemoveAsync(CacheKeys.Product(command.Id.Value));
                        }
                        await _cache.RemoveByPatternAsync("products:*");
                        break;
                }

                _logger.LogDebug("Кэш инвалидирован для {RequestType}", request.GetType().Name);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Ошибка инвалидации кэша для {RequestType}", request.GetType().Name);
            }
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Common\Behaviors\CachingBehavior.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Products.Queries;
using CubArt.Infrastructure.Caching;
using MediatR;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System.Text.Json;

namespace CubArt.Application.Common.Behaviors
{
    public class CachingBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
    where TResponse : Result
    {
        private readonly IRedisCacheService _cache;
        private readonly ILogger<CachingBehavior<TRequest, TResponse>> _logger;

        public CachingBehavior(
            IRedisCacheService cache,
            ILogger<CachingBehavior<TRequest, TResponse>> logger)
        {
            _cache = cache;
            _logger = logger;
        }

        public async Task<TResponse> Handle(
            TRequest request,
            RequestHandlerDelegate<TResponse> next,
            CancellationToken cancellationToken)
        {
            // Кэшируем только Query
            if (!IsQueryRequest(request))
                return await next();

            var cacheKey = GetCacheKey(request);
            if (string.IsNullOrEmpty(cacheKey))
                return await next();

            try
            {
                // Пробуем получить из кэша
                var cachedResult = await _cache.GetAsync<TResponse>(cacheKey);
                if (cachedResult != null)
                {
                    _logger.LogDebug("Возвращаем данные из кэша для {CacheKey}", cacheKey);
                    return cachedResult;
                }

                // Если нет в кэше - выполняем запрос
                var result = await next();

                // Сохраняем в кэш если успешно
                if (result.IsSuccess)
                {
                    var expiry = GetCacheExpiry(request);
                    await _cache.SetAsync(cacheKey, result, expiry);
                }

                return result;
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Ошибка кэширования для {CacheKey}", cacheKey);
                return await next(); // При ошибках кэша просто выполняем запрос
            }
        }

        private static bool IsQueryRequest(TRequest request)
        {
            return request.GetType().Name.EndsWith("Query");
        }

        private static string GetCacheKey(TRequest request)
        {
            return request switch
            {
                GetProductByIdQuery query => CacheKeys.Product(query.Id),
                GetAllProductsQuery query => CacheKeys.ProductsList(GetJsonStingValues(JsonSerializer.Serialize(query))),
                _ => string.Empty
            };
        }
        private TimeSpan GetCacheExpiry(TRequest request)
        {
            return request switch
            {
                GetProductByIdQuery => CacheSettings.ProductDetails,
                GetAllProductsQuery => CacheSettings.ProductList,
                _ => CacheSettings.Default
            };
        }

        private static string GetJsonStingValues(string jsonString)
        {
            using JsonDocument doc = JsonDocument.Parse(jsonString);

            string result = "";
            foreach (var property in doc.RootElement.EnumerateObject())
            {
                if (!string.IsNullOrEmpty(result))
                    result += ":";
                result += $"{property.Name}_{property.Value}";
            }
            return result;
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Common\Behaviors\LoggingBehavior.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Domain.Entities;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Interfaces;
using MediatR;
using Microsoft.Extensions.Logging;
using System.Text.Json;

namespace CubArt.Application.Common.Behaviors
{
    public class LoggingBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
    where TResponse : Result
    {
        private readonly ILogger<LoggingBehavior<TRequest, TResponse>> _logger;
        private readonly ISystemLogRepository _logRepository;

        public LoggingBehavior(
            ILogger<LoggingBehavior<TRequest, TResponse>> logger,
            ISystemLogRepository logRepository)
        {
            _logger = logger;
            _logRepository = logRepository;
        }

        public async Task<TResponse> Handle(
            TRequest request,
            RequestHandlerDelegate<TResponse> next,
            CancellationToken cancellationToken)
        {
            var requestName = typeof(TRequest).Name;
            string? userId = null;

            _logger.LogInformation("Обработка команды {CommandName} пользователем {UserId}", requestName, userId);

            try
            {
                var result = await next();

                if (result.IsSuccess)
                {
                    await LogSuccessAsync(requestName, request, userId, cancellationToken);
                }
                else
                {
                    await LogFailureAsync(requestName, request, result.ErrorMessage, result.ExceptionMessage, userId, cancellationToken);
                }

                return result;
            }
            catch (Exception ex)
            {
                await LogErrorAsync(requestName, request, ex, userId, cancellationToken);
                throw;
            }
        }

        private async Task LogSuccessAsync(string requestName, TRequest request, string? userId, CancellationToken cancellationToken)
        {
            try
            {
                var log = new SystemLog(
                    "Information", 
                    $"Успешно выполнено: {requestName}", 
                    userId,
                    source: "Application",
                    action: "Execute",
                    entityType: request.GetType().Name,
                    additionalData: GetRequestData(request)
                );

                await _logRepository.AddAsync(log);
            }
            catch (Exception logEx)
            {
                _logger.LogWarning(logEx, "Не удалось записать лог успешного выполнения для {RequestName}", requestName);
            }
        }

        private async Task LogFailureAsync(string requestName, TRequest request, string error, string? exceptionMessage, string? userId, CancellationToken cancellationToken)
        {
            try
            {
                var log = new SystemLog(
                    "Warning", 
                    $"Ошибка выполнения: {requestName} - {error}", 
                    userId,
                    source: "Application",
                    action: "Execute",
                    entityType: request.GetType().Name,
                    additionalData: JsonSerializer.Serialize(new
                    {
                        RequestData = GetRequestData(request),
                        ExceptionMessage = exceptionMessage
                    })
                );

                await _logRepository.AddAsync(log);
            }
            catch (Exception logEx)
            {
                _logger.LogWarning(logEx, "Не удалось записать лог ошибки выполнения для {RequestName}", requestName);
            }
        }

        private async Task LogErrorAsync(string requestName, TRequest request, Exception exception, string? userId, CancellationToken cancellationToken)
        {
            try
            {
                var log = new SystemLog(
                    "Error", 
                    $"Исключение при выполнении: {requestName} - {exception.Message}", 
                    userId,
                    source: "Application",
                    action: "Execute",
                    entityType: request.GetType().Name,
                    exceptionType: exception.GetType().Name,
                    additionalData: JsonSerializer.Serialize(new
                    {
                        RequestData = GetRequestData(request),
                        Exception = exception.GetFullExceptionDetails()
                    })
                );

                await _logRepository.AddAsync(log);
            }
            catch (Exception logEx)
            {
                _logger.LogWarning(logEx, "Не удалось записать лог исключения для {RequestName}", requestName);
            }
        }

        private string GetRequestData(TRequest request)
        {
            try
            {
                // Исключаем чувствительные данные (пароли и т.д.)
                var properties = request.GetType().GetProperties()
                    .Where(p => !p.Name.ToLower().Contains("password"))
                    .ToDictionary(p => p.Name, p => p.GetValue(request)?.ToString() ?? "null");

                return JsonSerializer.Serialize(properties);
            }
            catch
            {
                return "{}";
            }
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Common\Behaviors\QueryableExtensions.cs
================================================================================

using CubArt.Application.Common.Models;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Application.Common.Behaviors
{
    public static class QueryableExtensions
    {
        public static async Task<PagedListDto<T>> ToPagedListAsync<T>(
            this IQueryable<T> query,
            int pageNumber,
            int pageSize,
            CancellationToken cancellationToken = default)
        {
            var totalCount = await query.CountAsync(cancellationToken);
            var items = await query
                .Skip((pageNumber - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync(cancellationToken);

            return PagedListDto<T>.Create(items, totalCount, pageNumber, pageSize);
        }

        public static IQueryable<T> ApplySorting<T>(
            this IQueryable<T> query,
            string sortBy,
            bool sortDescending,
            Dictionary<string, Func<IQueryable<T>, IQueryable<T>>> sortMap)
        {
            if (sortMap.TryGetValue(sortBy.ToLower(), out var sortFunc))
            {
                return sortDescending
                    ? ReverseSort(query, sortFunc)
                    : sortFunc(query);
            }

            return query;
        }

        private static IQueryable<T> ReverseSort<T>(IQueryable<T> query, Func<IQueryable<T>, IQueryable<T>> sortFunc)
        {
            return sortFunc(query).Reverse();
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Common\Behaviors\ValidationBehavior.cs
================================================================================

using CubArt.Application.Common.Models;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Common.Behaviors
{
    public class ValidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
    where TResponse : Result
    {
        private readonly IEnumerable<IValidator<TRequest>> _validators;

        public ValidationBehavior(IEnumerable<IValidator<TRequest>> validators)
        {
            _validators = validators;
        }

        public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
        {
            var requestName = typeof(TRequest).Name;

            // Если нет валидаторов - пропускаем
            if (!_validators.Any())
            {
                return await next();
            }

            var context = new ValidationContext<TRequest>(request);

            var validationResults = await Task.WhenAll(
                _validators.Select(v => v.ValidateAsync(context, cancellationToken)));

            var failures = validationResults
                .SelectMany(result => result.Errors)
                .Where(f => f != null)
                .ToList();

            if (failures.Any())
            {
                var errorMessages = failures.Select(f => f.ErrorMessage).ToArray();

                if (typeof(TResponse) == typeof(Result))
                {
                    return (TResponse)(object)Result.Failure(errorMessages);
                }
                else
                {
                    // Получаем тип значения из Result<T>
                    var valueType = typeof(TResponse).GetGenericArguments()[0];

                    // Ищем метод Failure с параметрами string[] и Exception (последний необязательный)
                    var failureMethod = typeof(Result)
                        .GetMethods()
                        .First(m => m.Name == "Failure" &&
                                   m.IsGenericMethod &&
                                   m.GetParameters().Length == 2 &&
                                   m.GetParameters()[0].ParameterType == typeof(string[]) &&
                                   m.GetParameters()[1].ParameterType == typeof(Exception))
                        .MakeGenericMethod(valueType);

                    // Вызываем с двумя параметрами (exception = null)
                    return (TResponse)failureMethod.Invoke(null, new object[] { errorMessages, null });
                }
            }

            return await next();

        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Common\Mapping\MappingProfile.cs
================================================================================

using AutoMapper;
using CubArt.Application.Common.Models;
using CubArt.Application.Payments.DTOs;
using CubArt.Application.Productions.DTOs;
using CubArt.Application.Products.DTOs;
using CubArt.Application.Purchases.DTOs;
using CubArt.Application.Supplies.DTOs;
using CubArt.Domain.Entities;
using CubArt.Domain.Enums;

namespace CubArt.Application.Common.Mapping
{
    public class MappingProfile : Profile
    {
        public MappingProfile()
        {
            CreateMap<Purchase, PurchaseDto>();
            CreateMap<Payment, PaymentDto>();
            CreateMap<Supply, SupplyDto>();
            CreateMap<Production, ProductionDto>();
            CreateMap<StockMovement, StockMovementDto>()
                .ForMember(dest => dest.FacilityName, opt => opt.MapFrom(src => src.Facility.Name))
                .ForMember(dest => dest.ProductName, opt => opt.MapFrom(src => src.Product.Name))
                .ForMember(dest => dest.Quantity, opt => opt.MapFrom(src => src.OperationType == OperationTypeEnum.Income ? src.Quantity : src.Quantity * -1));

            CreateMap<Product, ProductDto>()
                .ForMember(dest => dest.ActiveSpecification,
                       opt => opt.MapFrom(src => src.ProductSpecifications
                           .FirstOrDefault(ps => ps.IsActive)));

            CreateMap<ProductSpecification, ProductSpecificationDto>();
            CreateMap<ProductSpecificationItem, ProductSpecificationItemDto>()
                .ForMember(dest => dest.ProductName, opt => opt.MapFrom(src => src.Product.Name))
                .ForMember(dest => dest.ProductType, opt => opt.MapFrom(src => src.Product.ProductType))
                .ForMember(dest => dest.UnitOfMeasure, opt => opt.MapFrom(src => src.Product.UnitOfMeasure));

        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Common\Models\BaseActionDto.cs
================================================================================

namespace CubArt.Application.Common.Models
{
    public abstract class BaseActionDto
    {
        public IEnumerable<StockMovementDto> StockMovementList { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Common\Models\BaseQuery.cs
================================================================================

namespace CubArt.Application.Common.Models
{
    public abstract class BaseQuery
    {
        public int PageNumber { get; set; } = MinPageSize;
        public int PageSize { get; set; } = DefaultPageSize;
        public string? SortBy { get; set; }
        public bool SortDescending { get; set; } = false;

        protected const int MinPageSize = 1;
        protected const int MaxPageSize = 1000;
        protected const int MinPageNumber = 1;
        protected const int MaxPageNumber = 1000;
        protected const int DefaultPageSize = 20;
        protected virtual string DefaultSortBy => "datecreated";

        public virtual void Normalize()
        {
            PageNumber = Math.Clamp(PageNumber, MinPageNumber, MaxPageNumber);
            PageSize = Math.Clamp(PageSize, MinPageSize, MaxPageSize); // Ограничиваем размер страницы
            SortBy ??= DefaultSortBy;
        }
    }

    public abstract class BaseDateFilterQuery : BaseQuery
    {
        public DateTime? StartDate { get; set; }
        public DateTime? EndDate { get; set; }

        public override void Normalize()
        {
            base.Normalize();

            // Корректируем даты для правильного фильтра
            if (EndDate.HasValue)
            {
                EndDate = EndDate.Value.Date.AddDays(1).AddTicks(-1); // Конец дня
            }
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Common\Models\PagedListDto.cs
================================================================================

using System.Text.Json.Serialization;

namespace CubArt.Application.Common.Models
{
    public class PagedListDto<T>
    {
        public List<T> Items { get; set; } = new();
        public int TotalCount { get; set; }
        public int PageNumber { get; set; }
        public int PageSize { get; set; }
        public int TotalPages { get; set; }
        public bool HasPreviousPage { get; set; }
        public bool HasNextPage { get; set; }

        [JsonConstructor]
        public PagedListDto(List<T> items, int totalCount, int pageNumber, int pageSize, int totalPages, bool hasPreviousPage, bool hasNextPage)
        {
            Items = items;
            TotalCount = totalCount;
            PageNumber = pageNumber;
            PageSize = pageSize;
            TotalPages = totalPages;
            HasPreviousPage = hasPreviousPage;
            HasNextPage = hasNextPage;
        }

        public static PagedListDto<T> Create(List<T> items, int totalCount, int pageNumber, int pageSize)
        {
            var totalPages = (int)Math.Ceiling(totalCount / (double)pageSize);

            return new PagedListDto<T>(
                items,
                totalCount,
                pageNumber,
                pageSize,
                totalPages,
                pageNumber > 1,
                pageNumber < totalPages
            );
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Common\Models\Result.cs
================================================================================

using CubArt.Domain.Exceptions;
using System.Text.Json.Serialization;

namespace CubArt.Application.Common.Models
{
    // Result pattern для обработки успехов/ошибок
    public class Result
    {
        public bool IsSuccess { get; }
        private string[] Errors { get; }
        public string? ErrorMessage => Errors.Length > 0 ? string.Join(Environment.NewLine, Errors) : null;

        [JsonIgnore]
        public string? ExceptionMessage { get; }

        [JsonConstructor]
        protected Result(bool isSuccess, string[] errors, Exception? exception = null)
        {
            IsSuccess = isSuccess;
            Errors = errors ?? Array.Empty<string>();
            ExceptionMessage = exception?.GetFullExceptionDetails();
        }

        public static Result Success() => new Result(true, Array.Empty<string>());
        public static Result<T> Success<T>(T value) => new Result<T>(value, true, Array.Empty<string>());
        public static Result Failure(string error, Exception? exception = null) => new Result(false, new[] { error }, exception);
        public static Result Failure(string[] errors, Exception? exception = null) => new Result(false, errors, exception);
        public static Result<T> Failure<T>(string error, Exception? exception = null) => new Result<T>(default, false, new[] { error }, exception);
        public static Result<T> Failure<T>(string[] errors, Exception? exception = null) => new Result<T>(default, false, errors, exception);
    }

    public class Result<T> : Result
    {
        private readonly T _data;

        public T Data
        {
            get
            {
                //if (!IsSuccess)
                //    throw new InvalidOperationException("Cannot access Value of failed result");
                return _data;
            }
        }

        [JsonConstructor]
        protected internal Result(T data, bool isSuccess, string[] errors, Exception? exception = null) : base(isSuccess, errors, exception)
        {
            _data = data;
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Common\Models\StockMovementDto.cs
================================================================================

namespace CubArt.Application.Common.Models
{
    public class StockMovementDto
    {
        public string FacilityName { get; set; }
        public string ProductName { get; set; }
        public decimal Quantity { get; set; }
        public DateTime DateCreated { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Common\Services\AuthService.cs
================================================================================

using CubArt.Application.Users.DTOs;
using CubArt.Domain.Entities;
using CubArt.Domain.Enums;
using CubArt.Infrastructure.Interfaces;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

namespace CubArt.Application.Common.Services
{
    public interface IAuthService
    {
        string GenerateJwtToken(UserDto user);
        string HashPassword(string password);
        bool VerifyPassword(string password, string passwordHash);
        Task<Guid> GetCurrentUserIdAsync();
        Task<bool> HasPermissionAsync(PermissionEnum permission);
        Task<bool> HasAnyPermissionAsync(params PermissionEnum[] permissions);
        Task<bool> HasAllPermissionsAsync(params PermissionEnum[] permissions);
        Task<IEnumerable<PermissionEnum>> GetUserPermissionsAsync();
    }

    public class AuthService : IAuthService
    {
        private readonly IConfiguration _configuration;
        private readonly IHttpContextAccessor _httpContextAccessor;
        private readonly IUserRepository _userRepository;

        public AuthService(
            IConfiguration configuration,
            IHttpContextAccessor httpContextAccessor,
            IUserRepository userRepository)
        {
            _configuration = configuration;
            _httpContextAccessor = httpContextAccessor;
            _userRepository = userRepository;
        }
        public Guid? UserId
        {
            get
            {
                var userIdClaim = _httpContextAccessor.HttpContext?.User?
                    .FindFirst(ClaimTypes.NameIdentifier)?.Value;

                if (string.IsNullOrEmpty(userIdClaim) || !Guid.TryParse(userIdClaim, out var userId))
                    return null;

                return userId;
            }
        }

        public string GenerateJwtToken(UserDto user)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.ASCII.GetBytes(_configuration["Jwt:Secret"]);

            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(new[]
                {
                    new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
                    new Claim(ClaimTypes.Name, user.Username),
                    new Claim(ClaimTypes.Email, user.Email),
                    //new Claim("firstName", user.FirstName),
                    //new Claim("lastName", user.LastName)
                }),
                Expires = DateTime.UtcNow.AddDays(7),
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key),
                    SecurityAlgorithms.HmacSha256Signature),
                Issuer = _configuration["Jwt:Issuer"],
                Audience = _configuration["Jwt:Audience"]
            };

            var token = tokenHandler.CreateToken(tokenDescriptor);
            return tokenHandler.WriteToken(token);
        }

        public string HashPassword(string password)
        {
            return BCrypt.Net.BCrypt.EnhancedHashPassword(password);
        }

        public bool VerifyPassword(string password, string passwordHash)
        {
            return BCrypt.Net.BCrypt.EnhancedVerify(password, passwordHash);
        }

        public async Task<Guid> GetCurrentUserIdAsync()
        {
            if (!UserId.HasValue)
                throw new UnauthorizedAccessException("Пользователь не аутентифицирован");

            var user = await _userRepository.GetByIdAsync(UserId.Value);
            if (user == null || !user.IsActive)
                throw new UnauthorizedAccessException("Пользователь не найден или деактивирован");

            return UserId.Value;
        }

        public async Task<bool> HasPermissionAsync(PermissionEnum permission)
        {
            var userId = await GetCurrentUserIdAsync();
            var user = await _userRepository.GetByIdWithRolesAsync(userId);

            return user?.HasPermission(permission) ?? false;
        }

        public async Task<bool> HasAnyPermissionAsync(params PermissionEnum[] permissions)
        {
            var userPermissions = await GetUserPermissionsAsync();
            return permissions.Any(p => userPermissions.Contains(p));
        }

        public async Task<bool> HasAllPermissionsAsync(params PermissionEnum[] permissions)
        {
            var userPermissions = await GetUserPermissionsAsync();
            return permissions.All(p => userPermissions.Contains(p));
        }

        public async Task<IEnumerable<PermissionEnum>> GetUserPermissionsAsync()
        {
            var userId = await GetCurrentUserIdAsync();
            var user = await _userRepository.GetByIdWithRolesAsync(userId);

            return user?.GetPermissions() ?? Enumerable.Empty<PermissionEnum>();
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Common\Services\LogCleanupService.cs
================================================================================

using CubArt.Infrastructure.Interfaces;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace CubArt.Application.Common.Services
{
    public class LogCleanupService : BackgroundService
    {
        private readonly IServiceProvider _serviceProvider;
        private readonly ILogger<LogCleanupService> _logger;

        public LogCleanupService(IServiceProvider serviceProvider, ILogger<LogCleanupService> logger)
        {
            _serviceProvider = serviceProvider;
            _logger = logger;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    using var scope = _serviceProvider.CreateScope();
                    var logRepository = scope.ServiceProvider.GetRequiredService<ISystemLogRepository>();

                    var deleteBefore = DateTime.UtcNow.AddMonths(-6); // Храним 6 месяцев
                    await logRepository.CleanOldLogsAsync(deleteBefore, stoppingToken);

                    _logger.LogInformation("Очистка логов выполнена. Удалены логи старше {Date}", deleteBefore);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Ошибка при очистке логов");
                }

                await Task.Delay(TimeSpan.FromDays(1), stoppingToken); // Запускаем раз в день
            }
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Payments\Commands\CreateOrUpdatePaymentCommand.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Payments.DTOs;
using CubArt.Domain.Enums;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Payments.Commands
{
    public class CreateOrUpdatePaymentCommand : IRequest<Result<PaymentDto>>
    {
        public Guid? Id { get; init; }
        public Guid PurchaseId { get; set; }
        public decimal Amount { get; set; }
        public PaymentMethodEnum PaymentMethod { get; set; }
    }

    public class CreateOrUpdatePaymentCommandValidator : AbstractValidator<CreateOrUpdatePaymentCommand>
    {
        public CreateOrUpdatePaymentCommandValidator()
        {
            RuleFor(x => x.PurchaseId).NotEmpty();
            RuleFor(x => x.Amount).GreaterThan(0);
            RuleFor(x => x.PaymentMethod).NotEmpty().IsInEnum();
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Payments\Commands\DeletePaymentByIdCommand.cs
================================================================================

using CubArt.Application.Common.Models;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Payments.Commands
{
    public class DeletePaymentByIdCommand : IRequest<Result>
    {
        public Guid Id { get; init; }
    }

    public class DeletePaymentByIdCommandValidator : AbstractValidator<DeletePaymentByIdCommand>
    {
        public DeletePaymentByIdCommandValidator()
        {
            RuleFor(x => x.Id).NotEmpty();
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Payments\DTOs\PaymentDto.cs
================================================================================

using CubArt.Domain.Enums;

namespace CubArt.Application.Payments.DTOs
{
    public class PaymentDto
    {
        public Guid Id { get; set; }
        public Guid PurchaseId { get; set; }
        public decimal Amount { get; set; }
        public PaymentMethodEnum PaymentMethod { get; set; }
        public PaymentStatusEnum PaymentStatus { get; set; }
        public DateTime DateCreated { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Payments\Handlers\CreateOrUpdatePaymentCommandHandler.cs
================================================================================

using AutoMapper;
using CubArt.Application.Common.Models;
using CubArt.Application.Payments.Commands;
using CubArt.Application.Payments.DTOs;
using CubArt.Application.Purchases.DTOs;
using CubArt.Domain.Entities;
using CubArt.Domain.Enums;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Payments.Handlers
{
    public class CreateOrUpdatePaymentCommandHandler : IRequestHandler<CreateOrUpdatePaymentCommand, Result<PaymentDto>>
    {
        private readonly IPaymentRepository _paymentRepository;
        private readonly IPurchaseRepository _purchaseRepository;
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;

        public CreateOrUpdatePaymentCommandHandler(
            IPaymentRepository paymentRepository,
            IPurchaseRepository purchaseRepository,
            IUnitOfWork unitOfWork,
            IMapper mapper)
        {
            _paymentRepository = paymentRepository;
            _purchaseRepository = purchaseRepository;
            _unitOfWork = unitOfWork;
            _mapper = mapper;
        }

        public async Task<Result<PaymentDto>> Handle(CreateOrUpdatePaymentCommand request, CancellationToken cancellationToken)
        {
            try
            {
                // Проверяем существование закупки
                var purchase = await _purchaseRepository.GetByIdAsync(request.PurchaseId);
                if (purchase == null)
                {
                    throw new NotFoundException(nameof(Purchase), request.PurchaseId);
                }

                var deniedStatuses = new PurchaseStatusEnum[] { PurchaseStatusEnum.Completed, PurchaseStatusEnum.Paid };
                if (deniedStatuses.Contains(purchase.PurchaseStatus))
                {
                    return Result.Failure<PaymentDto>($"Ошибка при сохранении оплаты: Данная закупка оплачена");
                }

                var paymentId = request.Id;
                // Проверяем, не превышает ли оплата оставшуюся сумму
                var paidAmount = await _paymentRepository.GetTotalPaidAmountAsync(request.PurchaseId, paymentId);
                var remainingAmount = purchase.Amount - paidAmount;

                if (request.Amount > remainingAmount)
                {
                    return Result.Failure<PaymentDto>($"Сумма оплаты {request.Amount} превосходит оставшуюся сумму {remainingAmount}");
                }

                Payment? payment;
                if (paymentId is null)
                {
                    // Создаем оплату
                    payment = new Payment(
                        request.PurchaseId,
                        request.Amount,
                        request.PaymentMethod);

                    await _paymentRepository.AddAsync(payment);
                }
                else
                {
                    // Обновление оплаты
                    payment = await _paymentRepository.GetByIdAsync(paymentId.Value);
                    if (payment == null)
                    {
                        throw new NotFoundException(nameof(Payment), paymentId.Value);
                    }

                    payment.UpdateEntity(
                        request.PurchaseId,
                        request.Amount,
                        request.PaymentMethod);

                    _paymentRepository.Update(payment);
                }

                // Если оплата полная, то переводим статус закупки
                if (remainingAmount - request.Amount == 0)
                {
                    purchase.PurchaseStatus = PurchaseStatusEnum.Paid;
                    _purchaseRepository.Update(purchase);
                }

                await _unitOfWork.CommitAsync(cancellationToken);

                return Result.Success(_mapper.Map<PaymentDto>(payment));
            }
            catch (Exception ex)
            {
                return Result.Failure<PaymentDto>($"Ошибка при создании оплаты: {ex.Message}", ex);
            }
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Payments\Handlers\DeletePaymentByIdCommandHandler.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Payments.Commands;
using CubArt.Application.Payments.DTOs;
using CubArt.Domain.Entities;
using CubArt.Domain.Enums;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Payments.Handlers
{
    public class DeletePaymentByIdCommandHandler : IRequestHandler<DeletePaymentByIdCommand, Result>
    {
        private readonly IPaymentRepository _paymentRepository;
        private readonly IPurchaseRepository _purchaseRepository;
        private readonly IUnitOfWork _unitOfWork;

        public DeletePaymentByIdCommandHandler(
            IPaymentRepository paymentRepository,
            IPurchaseRepository purchaseRepository,
            IUnitOfWork unitOfWork)
        {
            _paymentRepository = paymentRepository;
            _purchaseRepository = purchaseRepository;
            _unitOfWork = unitOfWork;
        }

        public async Task<Result> Handle(DeletePaymentByIdCommand request, CancellationToken cancellationToken)
        {
            try
            {
                // Проверяем существование оплаты
                var payment = await _paymentRepository.GetByIdAsync(request.Id);
                if (payment == null)
                {
                    throw new NotFoundException(nameof(Payment), request.Id);
                }

                // Проверяем закупку
                var purchase = await _purchaseRepository.GetByIdAsync(payment.PurchaseId);
                if (purchase == null)
                {
                    throw new NotFoundException(nameof(Purchase), payment.PurchaseId);
                }

                var deniedStatuses = new PurchaseStatusEnum[] { PurchaseStatusEnum.Completed, PurchaseStatusEnum.Paid };
                if (deniedStatuses.Contains(purchase.PurchaseStatus))
                {
                    return Result.Failure<PaymentDto>($"Ошибка при удалении оплаты: Нельзя редактировать оплаченную закупку");
                }

                _paymentRepository.Delete(payment);
                await _unitOfWork.CommitAsync(cancellationToken);

                return Result.Success();
            }
            catch (Exception ex)
            {
                return Result.Failure<PaymentDto>($"Ошибка при удалении оплаты: {ex.Message}", ex);
            }
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Payments\Handlers\GetAllPaymentsQueryHandler.cs
================================================================================

using AutoMapper;
using AutoMapper.QueryableExtensions;
using CubArt.Application.Common.Behaviors;
using CubArt.Application.Common.Models;
using CubArt.Application.Payments.DTOs;
using CubArt.Application.Payments.Queries;
using CubArt.Domain.Entities;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Payments.Handlers
{
    public class GetAllPaymentsQueryHandler : IRequestHandler<GetAllPaymentsQuery, Result<PagedListDto<PaymentDto>>>
    {
        private readonly IPaymentRepository _paymentRepository;
        private readonly IMapper _mapper;

        private readonly Dictionary<string, Func<IQueryable<Payment>, IQueryable<Payment>>> _sortMap = new()
        {
            ["amount"] = q => q.OrderBy(p => p.Amount),
            ["paymentmethod"] = q => q.OrderBy(p => p.PaymentMethod),
            ["paymentstatus"] = q => q.OrderBy(p => p.PaymentStatus),
            ["datecreated"] = q => q.OrderBy(p => p.DateCreated)
        };


        public GetAllPaymentsQueryHandler(
            IPaymentRepository paymentRepository,
            IMapper mapper)
        {
            _paymentRepository = paymentRepository;
            _mapper = mapper;
        }

        public async Task<Result<PagedListDto<PaymentDto>>> Handle(GetAllPaymentsQuery request, CancellationToken cancellationToken)
        {
            try
            {
                request.Normalize();

                var query = _paymentRepository.GetQueryable()
                    .AsQueryable();

                // Фильтрация
                query = ApplyFilters(query, request);

                // Сортировка
                query = query.ApplySorting(request.SortBy, request.SortDescending, _sortMap);

                // Проекция и пагинация
                var projectedQuery = query.ProjectTo<PaymentDto>(_mapper.ConfigurationProvider);
                var result = await projectedQuery.ToPagedListAsync(request.PageNumber, request.PageSize, cancellationToken);

                return Result.Success(result);
            }
            catch (Exception ex)
            {
                return Result.Failure<PagedListDto<PaymentDto>>($"Ошибка получения оплат: {ex.Message}", ex);
            }
        }

        private static IQueryable<Payment> ApplyFilters(IQueryable<Payment> query, GetAllPaymentsQuery request)
        {
            if (request.PurchaseId.HasValue)
            {
                query = query.Where(p => p.PurchaseId == request.PurchaseId.Value);
            }

            if (request.PaymentMethod.HasValue)
            {
                query = query.Where(p => p.PaymentMethod == request.PaymentMethod.Value);
            }

            if (request.PaymentStatus.HasValue)
            {
                query = query.Where(p => p.PaymentStatus == request.PaymentStatus.Value);
            }

            if (request.StartDate.HasValue)
            {
                query = query.Where(p => p.DateCreated >= request.StartDate.Value);
            }

            if (request.EndDate.HasValue)
            {
                query = query.Where(p => p.DateCreated <= request.EndDate.Value);
            }

            return query;
        }

    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Payments\Handlers\GetPaymentByIdQueryHandler.cs
================================================================================

using AutoMapper;
using CubArt.Application.Common.Models;
using CubArt.Application.Payments.DTOs;
using CubArt.Application.Payments.Queries;
using CubArt.Application.Supplies.Queries;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Payments.Handlers
{
    public class GetPaymentByIdQueryHandler : IRequestHandler<GetPaymentByIdQuery, Result<PaymentDto>>
    {
        private readonly IPaymentRepository _paymentRepository;
        private readonly IMapper _mapper;

        public GetPaymentByIdQueryHandler(
            IPaymentRepository paymentRepository,
            IMapper mapper)
        {
            _paymentRepository = paymentRepository;
            _mapper = mapper;
        }

        public async Task<Result<PaymentDto>> Handle(GetPaymentByIdQuery request, CancellationToken cancellationToken)
        {
            try
            {
                var payment = await _paymentRepository.GetByIdAsync(request.Id);
                if (payment is null)
                {
                    throw new NotFoundException(nameof(payment), request.Id);
                }

                return Result.Success(_mapper.Map<PaymentDto>(payment));
            }
            catch (Exception ex)
            {
                return Result.Failure<PaymentDto>($"Ошибка получения оплаты: {ex.Message}", ex);
            }
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Payments\Queries\GetAllPaymentsQuery.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Payments.DTOs;
using CubArt.Domain.Enums;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Payments.Queries
{
    public class GetAllPaymentsQuery : BaseDateFilterQuery, IRequest<Result<PagedListDto<PaymentDto>>>
    {
        public Guid? PurchaseId { get; set; }
        public PaymentMethodEnum? PaymentMethod { get; set; }
        public PaymentStatusEnum? PaymentStatus { get; set; }

        protected override string DefaultSortBy => "datecreated";

    }

    // Validator
    public class GetAllPaymentsQueryValidator : AbstractValidator<GetAllPaymentsQuery>
    {
        public GetAllPaymentsQueryValidator()
        {
            RuleFor(x => x.PaymentMethod).IsInEnum().When(x => x.PaymentMethod.HasValue);
            RuleFor(x => x.PaymentStatus).IsInEnum().When(x => x.PaymentStatus.HasValue);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Payments\Queries\GetPaymentByIdQuery.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Payments.DTOs;
using MediatR;

namespace CubArt.Application.Payments.Queries
{
    public record GetPaymentByIdQuery(Guid Id) : IRequest<Result<PaymentDto>>;
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Productions\Commands\CreateOrUpdateProductionCommand.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Productions.DTOs;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Productions.Commands
{
    public class CreateOrUpdateProductionCommand : IRequest<Result<ProductionDto>>
    {
        public Guid? Id { get; init; }
        public int ProductId { get; set; }
        public int FacilityId { get; set; }
        public decimal Quantity { get; set; }
    }

    // Validator
    public class CreateOrUpdateProductionCommandValidator : AbstractValidator<CreateOrUpdateProductionCommand>
    {
        public CreateOrUpdateProductionCommandValidator()
        {
            RuleFor(x => x.ProductId).GreaterThan(0);
            RuleFor(x => x.FacilityId).GreaterThan(0);
            RuleFor(x => x.Quantity).GreaterThan(0);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Productions\Commands\DeleteProductionByIdCommand.cs
================================================================================

using CubArt.Application.Common.Models;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Productions.Commands
{
    public class DeleteProductionByIdCommand : IRequest<Result>
    {
        public Guid Id { get; init; }
    }

    // Validator
    public class DeleteProductionByIdValidator : AbstractValidator<DeleteProductionByIdCommand>
    {
        public DeleteProductionByIdValidator()
        {
            RuleFor(x => x.Id).NotNull();
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Productions\DTOs\ProductionDto.cs
================================================================================

using CubArt.Application.Common.Models;

namespace CubArt.Application.Productions.DTOs
{
    public class ProductionDto : BaseActionDto
    {
        public Guid Id { get; set; }
        public string ProductName { get; set; }
        public string FacilityName { get; set; }
        public decimal Quantity { get; set; }
        public DateTime DateCreated { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Productions\Handlers\CreateOrUpdateProductionCommandHandler.cs
================================================================================

using AutoMapper;
using CubArt.Application.Common.Models;
using CubArt.Application.Productions.Commands;
using CubArt.Application.Productions.DTOs;
using CubArt.Application.Productions.Queries;
using CubArt.Domain.Entities;
using CubArt.Domain.Enums;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Common;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using CubArt.Infrastructure.Models;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Application.Productions.Handlers
{
    public class CreateOrUpdateProductionCommandHandler : IRequestHandler<CreateOrUpdateProductionCommand, Result<ProductionDto>>
    {
        private readonly IProductionRepository _productionRepository;
        private readonly IRepository<Product, int> _productRepository;
        private readonly IRepository<Facility, int> _facilityRepository;
        private readonly IRepository<ProductSpecification, int> _specificationRepository;
        private readonly IRepository<StockMovement, Guid> _stockMovementRepository;
        private readonly IStockMovementService _stockMovementService;
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;
        private readonly IMediator _mediator;

        public CreateOrUpdateProductionCommandHandler(
            IProductionRepository productionRepository,
            IRepository<Product, int> productRepository,
            IRepository<Facility, int> facilityRepository,
            IRepository<ProductSpecification, int> specificationRepository,
            IRepository<StockMovement, Guid> stockMovementRepository,
            IStockMovementService stockMovementService,
            IUnitOfWork unitOfWork,
            IMapper mapper,
            IMediator mediator)

        {
            _productionRepository = productionRepository;
            _productRepository = productRepository;
            _facilityRepository = facilityRepository;
            _specificationRepository = specificationRepository;
            _stockMovementRepository = stockMovementRepository;
            _stockMovementService = stockMovementService;
            _unitOfWork = unitOfWork;
            _mapper = mapper;
            _mediator = mediator;
        }

        public async Task<Result<ProductionDto>> Handle(CreateOrUpdateProductionCommand request, CancellationToken cancellationToken)
        {
            using var transaction = await _unitOfWork.BeginTransactionAsync(cancellationToken);

            try
            {
                // Проверяем существование производства
                var facility = await _facilityRepository.GetByIdAsync(request.FacilityId);
                if (facility == null)
                {
                    throw new NotFoundException(nameof(Facility), request.FacilityId);
                }

                // Проверяем существование продукта
                var product = await _productRepository.GetByIdAsync(request.ProductId);
                if (product == null)
                {
                    throw new NotFoundException(nameof(Product), request.ProductId);
                }

                // Проверяем, что продукт не является сырьем
                if (product.ProductType == ProductTypeEnum.RawMaterial)
                {
                    await _unitOfWork.RollbackTransactionAsync(transaction, cancellationToken);
                    return Result.Failure<ProductionDto>("Нельзя производить продукт типа 'Сырье'");
                }

                // Получаем активную спецификацию продукта
                var activeSpecification = await _specificationRepository.GetQueryable()
                    .Include(ps => ps.Items)
                    .ThenInclude(psi => psi.Product)
                    .FirstOrDefaultAsync(ps => ps.ProductId == request.ProductId && ps.IsActive, cancellationToken);

                if (activeSpecification == null || !activeSpecification.Items.Any())
                {
                    await _unitOfWork.RollbackTransactionAsync(transaction, cancellationToken);
                    return Result.Failure<ProductionDto>($"Для продукта '{product.Name}' не найдена активная спецификация");
                }

                Production? production = null;
                var productionId = request.Id;
                if (productionId.HasValue)
                {
                    // Проверяем существование производства
                    production = await _productionRepository.GetByIdAsync(productionId.Value);
                    if (production == null)
                    {
                        throw new NotFoundException(nameof(Production), productionId.Value);
                    }

                    // Удаляем движения запасов
                    await _stockMovementService.DeleteStockMovements(productionId.Value, StockMovemetReferenceTypeEnum.Production);

                    // Пересчет балансов
                    await _stockMovementService.RecalculateAllBalancesFromDate(production.DateCreated.Date, production.FacilityId, production.ProductId);
                }

                // Проверяем достаточность остатков компонентов
                var componentValidationResult = await ValidateComponentAvailability(
                    activeSpecification.Items.ToList(), request.Quantity, request.FacilityId, cancellationToken);

                if (!componentValidationResult.IsSuccess)
                {
                    await _unitOfWork.RollbackTransactionAsync(transaction, cancellationToken);
                    return Result.Failure<ProductionDto>(componentValidationResult.ErrorMessage);
                }

                if (production is null)
                {
                    // Создаем запись о производстве
                    production = new Production(request.ProductId, request.FacilityId, request.Quantity);
                    await _productionRepository.AddAsync(production);
                }
                else
                {
                    // Обновляем запись о производстве
                    production.UpdateEntity(
                        request.ProductId,
                        request.FacilityId,
                        request.Quantity
                    );

                    _productionRepository.Update(production);
                }

                // Создаем движения запасов для списания компонентов
                await CreateComponentStockMovements(activeSpecification.Items.ToList(),
                    request.Quantity, request.FacilityId, production.Id, production.DateCreated, cancellationToken);

                // Создаем движение запасов для прихода произведенного продукта
                await CreateProductStockMovement(product, request.Quantity, request.FacilityId, production.Id, production.DateCreated, cancellationToken);

                if (productionId.HasValue)
                {
                    await _stockMovementService.UpdateStockMovementsAndRecalculateBalances(
                        new UpdateStockMovementsAndRecalculateBalancesModel(
                            production.Id,
                            OperationTypeEnum.Income,
                            StockMovemetReferenceTypeEnum.Supply,
                            production.DateCreated,
                            production.FacilityId,
                            production.ProductId,
                            request.Quantity
                        )
                    );
                }

                await _unitOfWork.CommitAsync(cancellationToken);
                await _unitOfWork.CommitTransactionAsync(transaction, cancellationToken);

                // Получаем полные данные для ответа
                return await _mediator.Send(new GetProductionByIdQuery(production.Id), cancellationToken);
            }
            catch (Exception ex)
            {
                await _unitOfWork.RollbackTransactionAsync(transaction, cancellationToken);
                return Result.Failure<ProductionDto>($"Ошибка при создании производства: {ex.Message}", ex);
            }
        }

        private async Task<Result> ValidateComponentAvailability(
            List<ProductSpecificationItem> specificationItems,
            decimal productionQuantity,
            int facilityId,
            CancellationToken cancellationToken)
        {
            foreach (var item in specificationItems)
            {
                // Получаем текущий остаток компонента на производстве
                var currentBalanceResult = await _stockMovementService.GetStockBalanceByDate(facilityId, item.ProductId, DateTime.UtcNow.Date);
                var currentBalance = currentBalanceResult.FinishBalance;
                var requiredQuantity = item.Quantity * productionQuantity;

                if (currentBalance < requiredQuantity)
                {
                    return Result.Failure(
                        $"Недостаточно компонента '{item.Product.Name}'. " +
                        $"Требуется: {requiredQuantity}, доступно: {currentBalance}");
                }
            }

            return Result.Success();
        }

        private async Task CreateComponentStockMovements(
            List<ProductSpecificationItem> specificationItems,
            decimal productionQuantity,
            int facilityId,
            Guid productionId,
            DateTime date,
            CancellationToken cancellationToken)
        {
            foreach (var item in specificationItems)
            {
                var movementQuantity = item.Quantity * productionQuantity;

                var movement = new StockMovement(
                    facilityId: facilityId,
                    productId: item.ProductId,
                    operationType: OperationTypeEnum.Outcome,
                    referenceType: StockMovemetReferenceTypeEnum.Production,
                    referenceId: productionId.ToString(),
                    quantity: movementQuantity,
                    dateCreated: date);

                await _stockMovementRepository.AddAsync(movement);
            }
        }

        private async Task CreateProductStockMovement(
            Product product,
            decimal quantity,
            int facilityId,
            Guid productionId,
            DateTime date,
            CancellationToken cancellationToken)
        {
            var movement = new StockMovement(
                facilityId: facilityId,
                productId: product.Id,
                operationType: OperationTypeEnum.Income,
                referenceType: StockMovemetReferenceTypeEnum.Production,
                referenceId: productionId.ToString(),
                quantity: quantity,
                dateCreated: date);

            await _stockMovementRepository.AddAsync(movement);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Productions\Handlers\DeleteProductionByIdCommandHandler.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Productions.Commands;
using CubArt.Application.Productions.DTOs;
using CubArt.Application.Productions.Queries;
using CubArt.Domain.Entities;
using CubArt.Domain.Enums;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Productions.Handlers
{
    public class DeleteProductionByIdCommandHandler : IRequestHandler<DeleteProductionByIdCommand, Result>
    {
        private readonly IProductionRepository _productionRepository;
        private readonly IStockMovementService _stockMovementService;
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMediator _mediator;

        public DeleteProductionByIdCommandHandler(
            IProductionRepository productionRepository,
            IStockMovementService stockMovementService,
            IUnitOfWork unitOfWork,
            IMediator mediator)

        {
            _productionRepository = productionRepository;
            _stockMovementService = stockMovementService;
            _unitOfWork = unitOfWork;
            _mediator = mediator;
        }

        public async Task<Result> Handle(DeleteProductionByIdCommand request, CancellationToken cancellationToken)
        {
            using var transaction = await _unitOfWork.BeginTransactionAsync(cancellationToken);

            try
            {                
                // Проверяем существование производства
                var production = await _productionRepository.GetByIdAsync(request.Id);
                if (production == null)
                {
                    throw new NotFoundException(nameof(Production), request.Id);
                }

                _productionRepository.Delete(production);

                // Удаляем движения запасов
                await _stockMovementService.DeleteStockMovements(production.Id, StockMovemetReferenceTypeEnum.Production);

                // Пересчет балансов
                await _stockMovementService.RecalculateAllBalancesFromDate(production.DateCreated.Date, production.FacilityId, production.ProductId);
                
                await _unitOfWork.CommitAsync(cancellationToken);
                await _unitOfWork.CommitTransactionAsync(transaction, cancellationToken);

                return Result.Success();
            }
            catch (Exception ex)
            {
                await _unitOfWork.RollbackTransactionAsync(transaction, cancellationToken);
                return Result.Failure<ProductionDto>($"Ошибка при удалении производства: {ex.Message}", ex);
            }
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Productions\Handlers\GetAllProductionsQueryHandler.cs
================================================================================

using AutoMapper;
using AutoMapper.QueryableExtensions;
using CubArt.Application.Common.Behaviors;
using CubArt.Application.Common.Models;
using CubArt.Application.Productions.DTOs;
using CubArt.Application.Productions.Queries;
using CubArt.Domain.Entities;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Productions.Handlers
{
    public class GetAllProductionsQueryHandler : IRequestHandler<GetAllProductionsQuery, Result<PagedListDto<ProductionDto>>>
    {
        private readonly IProductionRepository _productionRepository;
        private readonly IMapper _mapper;

        private readonly Dictionary<string, Func<IQueryable<Production>, IQueryable<Production>>> _sortMap = new()
        {
            ["productname"] = q => q.OrderBy(p => p.Product.Name),
            ["facilityname"] = q => q.OrderBy(p => p.Facility.Name),
            ["quantity"] = q => q.OrderBy(p => p.Quantity),
            ["datecreated"] = q => q.OrderBy(p => p.DateCreated)
        };


        public GetAllProductionsQueryHandler(
            IProductionRepository productionRepository,
            IMapper mapper)
        {
            _productionRepository = productionRepository;
            _mapper = mapper;
        }

        public async Task<Result<PagedListDto<ProductionDto>>> Handle(GetAllProductionsQuery request, CancellationToken cancellationToken)
        {
            try
            {
                request.Normalize();

                var query = _productionRepository.GetQueryable()
                    .AsQueryable();

                // Фильтрация
                query = ApplyFilters(query, request);

                // Сортировка
                query = query.ApplySorting(request.SortBy, request.SortDescending, _sortMap);

                // Проекция и пагинация
                var projectedQuery = query.ProjectTo<ProductionDto>(_mapper.ConfigurationProvider);
                var result = await projectedQuery.ToPagedListAsync(request.PageNumber, request.PageSize, cancellationToken);

                return Result.Success(result);
            }
            catch (Exception ex)
            {
                return Result.Failure<PagedListDto<ProductionDto>>($"Ошибка получения производств: {ex.Message}", ex);
            }
        }

        private static IQueryable<Production> ApplyFilters(IQueryable<Production> query, GetAllProductionsQuery request)
        {
            if (request.ProductId.HasValue)
            {
                query = query.Where(p => p.ProductId == request.ProductId.Value);
            }

            if (request.FacilityId.HasValue)
            {
                query = query.Where(p => p.FacilityId == request.FacilityId.Value);
            }

            if (request.StartDate.HasValue)
            {
                query = query.Where(p => p.DateCreated >= request.StartDate.Value);
            }

            if (request.EndDate.HasValue)
            {
                query = query.Where(p => p.DateCreated <= request.EndDate.Value);
            }

            return query;
        }

    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Productions\Handlers\GetProductionByIdQueryHandler.cs
================================================================================

using AutoMapper;
using CubArt.Application.Common.Models;
using CubArt.Application.Productions.DTOs;
using CubArt.Application.Productions.Queries;
using CubArt.Domain.Enums;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Productions.Handlers
{
    public class GetProductionByIdQueryHandler : IRequestHandler<GetProductionByIdQuery, Result<ProductionDto>>
    {
        private readonly IProductionRepository _productionRepository;
        private readonly IStockMovementService _stockMovementService;
        private readonly IMapper _mapper;

        public GetProductionByIdQueryHandler(
            IProductionRepository productionRepository,
            IStockMovementService stockMovementService,
            IMapper mapper)
        {
            _productionRepository = productionRepository;
            _stockMovementService = stockMovementService;
            _mapper = mapper;
        }

        public async Task<Result<ProductionDto>> Handle(GetProductionByIdQuery request, CancellationToken cancellationToken)
        {
            try
            {
                var production = await _productionRepository.GetByIdAsync(request.Id);
                if (production is null)
                {
                    throw new NotFoundException(nameof(production), request.Id);
                }

                var dto = _mapper.Map<ProductionDto>(production);
                var stockMovements = await _stockMovementService.GetStockMovementsByReference(production.Id.ToString(), StockMovemetReferenceTypeEnum.Production);
                dto.StockMovementList = _mapper.Map<IEnumerable<StockMovementDto>>(stockMovements);

                return Result.Success(dto);
            }
            catch (Exception ex)
            {
                return Result.Failure<ProductionDto>($"Ошибка получения производства: {ex.Message}", ex);
            }
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Productions\Queries\GetAllProductionsQuery.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Productions.DTOs;
using MediatR;

namespace CubArt.Application.Productions.Queries
{
    public class GetAllProductionsQuery : BaseDateFilterQuery, IRequest<Result<PagedListDto<ProductionDto>>>
    {
        public int? ProductId { get; set; }
        public int? FacilityId { get; set; }

        protected override string DefaultSortBy => "datecreated";

    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Productions\Queries\GetProductionByIdQuery.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Productions.DTOs;
using MediatR;

namespace CubArt.Application.Productions.Queries
{
    public record GetProductionByIdQuery(Guid Id) : IRequest<Result<ProductionDto>>;
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Products\Commands\CreateOrUpdateProductCommand.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Products.DTOs;
using CubArt.Domain.Enums;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Products.Commands
{
    public class CreateOrUpdateProductCommand : IRequest<Result<ProductDto>>
    {
        public int? Id { get; set; } // null для создания, значение для обновления
        public string Name { get; set; }
        public ProductTypeEnum ProductType { get; set; }
        public UnitOfMeasureEnum UnitOfMeasure { get; set; }
        public ProductSpecificationData? Specification { get; set; }
    }

    public class ProductSpecificationData
    {
        public string? Version { get; set; }
        public bool SetAsActive { get; set; } = true;
        public List<SpecificationItem> Items { get; set; } = new();
    }

    public class SpecificationItem
    {
        public int ProductId { get; set; }
        public decimal Quantity { get; set; }
    }

    public class CreateOrUpdateProductCommandValidator : AbstractValidator<CreateOrUpdateProductCommand>
    {
        public CreateOrUpdateProductCommandValidator()
        {
            RuleFor(x => x.Name).NotEmpty().MaximumLength(200);
            RuleFor(x => x.ProductType).IsInEnum();
            RuleFor(x => x.UnitOfMeasure).IsInEnum();

            When(x => x.Specification != null, () =>
            {
                RuleFor(x => x.Specification.Version).MaximumLength(50);
                RuleFor(x => x.Specification.Items).NotEmpty().When(x => x.Id.HasValue);
                RuleForEach(x => x.Specification.Items).ChildRules(item =>
                {
                    item.RuleFor(i => i.ProductId).GreaterThan(0);
                    item.RuleFor(i => i.Quantity).GreaterThan(0);
                });
            });
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Products\Commands\CreateProductCommand.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Products.DTOs;
using CubArt.Domain.Enums;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Products.Commands
{
    public class CreateProductCommand : IRequest<Result<ProductDto>>
    {
        public string Name { get; set; }
        public ProductTypeEnum ProductType { get; set; }
        public UnitOfMeasureEnum UnitOfMeasure { get; set; }
    }

    public class CreateProductCommandValidator : AbstractValidator<CreateProductCommand>
    {
        public CreateProductCommandValidator()
        {
            RuleFor(x => x.Name).NotEmpty().MaximumLength(200);
            RuleFor(x => x.ProductType).IsInEnum();
            RuleFor(x => x.UnitOfMeasure).IsInEnum();
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Products\DTOs\ProductDto.cs
================================================================================

using CubArt.Domain.Enums;

namespace CubArt.Application.Products.DTOs
{
    public class ProductDto
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public ProductTypeEnum ProductType { get; set; }
        public UnitOfMeasureEnum UnitOfMeasure { get; set; }
        public ProductSpecificationDto? ActiveSpecification { get; set; }

    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Products\DTOs\ProductSpecificationDto.cs
================================================================================

namespace CubArt.Application.Products.DTOs
{
    public class ProductSpecificationDto
    {
        public int Id { get; set; }
        public int ProductId { get; set; }
        public string? Version { get; set; }
        public bool IsActive { get; set; }
        public DateTime DateCreated { get; set; }
        public List<ProductSpecificationItemDto> Items { get; set; } = new();
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Products\DTOs\ProductSpecificationItemDto.cs
================================================================================

using CubArt.Domain.Enums;

namespace CubArt.Application.Products.DTOs
{
    public class ProductSpecificationItemDto
    {
        public int Id { get; set; }
        public int ProductSpecificationId { get; set; }
        public int ProductId { get; set; }
        public string ProductName { get; set; }
        public ProductTypeEnum ProductType { get; set; }
        public decimal Quantity { get; set; }
        public UnitOfMeasureEnum UnitOfMeasure { get; set; }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Products\Handlers\CreateOrUpdateProductCommandHandler.cs
================================================================================

using AutoMapper;
using CubArt.Application.Common.Models;
using CubArt.Application.Products.Commands;
using CubArt.Application.Products.DTOs;
using CubArt.Domain.Entities;
using CubArt.Domain.Enums;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Common;
using CubArt.Infrastructure.Data;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Application.Products.Handlers
{
    public class CreateOrUpdateProductCommandHandler : IRequestHandler<CreateOrUpdateProductCommand, Result<ProductDto>>
    {
        private readonly IRepository<Product, int> _productRepository;
        private readonly IRepository<ProductSpecification, int> _specificationRepository;
        private readonly IRepository<ProductSpecificationItem, int> _specificationItemRepository;
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;

        public CreateOrUpdateProductCommandHandler(
            IRepository<Product, int> productRepository,
            IRepository<ProductSpecification, int> specificationRepository,
            IRepository<ProductSpecificationItem, int> specificationItemRepository,
            IUnitOfWork unitOfWork,
            IMapper mapper)
        {
            _productRepository = productRepository;
            _specificationRepository = specificationRepository;
            _specificationItemRepository = specificationItemRepository;
            _unitOfWork = unitOfWork;
            _mapper = mapper;
        }

        public async Task<Result<ProductDto>> Handle(
            CreateOrUpdateProductCommand request,
            CancellationToken cancellationToken)
        {
            var transaction = await _unitOfWork.BeginTransactionAsync(cancellationToken);

            try
            {
                Product product;

                if (request.Id.HasValue)
                {
                    // Обновление существующего продукта
                    product = await UpdateProductAsync(request.Id.Value, request, cancellationToken);

                    // Обработка спецификации если предоставлена
                    if (request.Specification != null && request.Specification.Items.Any())
                    {
                        await HandleProductSpecificationAsync(product, request.Specification, cancellationToken);
                    }
                }
                else
                {
                    // Создание нового продукта
                    product = await CreateProductAsync(request, cancellationToken);

                    // Для нового продукта всегда создаем спецификацию если предоставлена
                    if (request.Specification != null && request.Specification.Items.Any())
                    {
                        await CreateNewSpecificationAsync(product, request.Specification, cancellationToken);
                    }
                }

                await _unitOfWork.CommitAsync(cancellationToken);
                await _unitOfWork.CommitTransactionAsync(transaction, cancellationToken);

                // Загружаем полные данные для ответа
                var fullProduct = await _productRepository.GetQueryable()
                    .Include(p => p.ProductSpecifications.Where(ps => ps.IsActive))
                    .ThenInclude(ps => ps.Items)
                    .ThenInclude(psi => psi.Product)
                    .FirstOrDefaultAsync(p => p.Id == product.Id, cancellationToken);

                var result = _mapper.Map<ProductDto>(fullProduct);
                return Result.Success(result);
            }
            catch (Exception ex)
            {
                await _unitOfWork.RollbackTransactionAsync(transaction, cancellationToken);
                return Result.Failure<ProductDto>($"Ошибка сохранения продукции: {ex.Message}");
            }
        }

        private async Task<Product> CreateProductAsync(CreateOrUpdateProductCommand request, CancellationToken cancellationToken)
        {
            // Проверяем уникальность имени
            var existingProduct = await _productRepository.GetQueryable()
                .FirstOrDefaultAsync(p => p.Name == request.Name, cancellationToken);

            if (existingProduct != null)
            {
                throw new DomainException($"Продукция с названием '{request.Name}' уже существует");
            }

            // Создаем продукт
            var product = new Product(request.Name, request.ProductType, request.UnitOfMeasure);
            await _productRepository.AddAsync(product);
            await _unitOfWork.CommitAsync(cancellationToken);

            return product;
        }

        private async Task<Product> UpdateProductAsync(int productId, CreateOrUpdateProductCommand request, CancellationToken cancellationToken)
        {
            var product = await _productRepository.GetByIdAsync(productId);
            if (product == null)
            {
                throw new NotFoundException(nameof(Product), productId);
            }

            // Проверяем уникальность имени (исключая текущий продукт)
            var existingProduct = await _productRepository.GetQueryable()
                .FirstOrDefaultAsync(p => p.Name == request.Name && p.Id != productId, cancellationToken);

            if (existingProduct != null)
            {
                throw new DomainException($"Продукция с названием '{request.Name}' уже существует");
            }

            // Обновляем свойства
            product.Name = request.Name;
            product.ProductType = request.ProductType;
            product.UnitOfMeasure = request.UnitOfMeasure;

            _productRepository.Update(product);

            return product;
        }

        private async Task HandleProductSpecificationAsync(
        Product product,
        ProductSpecificationData specificationData,
        CancellationToken cancellationToken)
        {
            // Получаем активную спецификацию продукта
            var activeSpecification = await _specificationRepository.GetQueryable()
                .Include(ps => ps.Items)
                .FirstOrDefaultAsync(ps => ps.ProductId == product.Id && ps.IsActive, cancellationToken);

            if (activeSpecification != null)
            {
                // Сравниваем с активной спецификацией
                if (AreSpecificationsEqual(activeSpecification.Items.ToList(), specificationData.Items))
                {
                    // Спецификации идентичны - просто обновляем свойства если нужно
                    await UpdateSpecificationPropertiesAsync(activeSpecification, specificationData, cancellationToken);
                }
                else
                {
                    // Спецификации разные - создаем новую и делаем ее активной
                    await DeactivateSpecificationAsync(activeSpecification, cancellationToken);
                    await CreateNewSpecificationAsync(product, specificationData, cancellationToken);                    
                }
            }
            else
            {
                // Нет активной спецификации - создаем новую
                await CreateNewSpecificationAsync(product, specificationData, cancellationToken);
            }
        }

        private bool AreSpecificationsEqual(List<ProductSpecificationItem> existingItems, List<SpecificationItem> newItems)
        {
            if (existingItems.Count != newItems.Count)
                return false;

            // Создаем словари для сравнения
            var existingDict = existingItems
                .GroupBy(x => x.ProductId)
                .ToDictionary(g => g.Key, g => g.Sum(x => x.Quantity));

            var newDict = newItems
                .GroupBy(x => x.ProductId)
                .ToDictionary(g => g.Key, g => g.Sum(x => x.Quantity));

            // Сравниваем количество по каждому ProductId
            if (existingDict.Count != newDict.Count)
                return false;

            foreach (var kvp in existingDict)
            {
                if (!newDict.TryGetValue(kvp.Key, out var newQuantity) ||
                    Math.Abs(newQuantity - kvp.Value) > 0.001m) // учитываем погрешность decimal
                {
                    return false;
                }
            }

            return true;
        }

        private async Task UpdateSpecificationPropertiesAsync(
            ProductSpecification specification,
            ProductSpecificationData specificationData,
            CancellationToken cancellationToken)
        {
            bool wasUpdated = false;

            // Обновляем версию если предоставлена и отличается
            if (!string.IsNullOrEmpty(specificationData.Version) &&
                specification.Version != specificationData.Version)
            {
                // Проверяем уникальность новой версии
                var existingWithSameVersion = await _specificationRepository.GetQueryable()
                    .FirstOrDefaultAsync(ps =>
                        ps.ProductId == specification.ProductId &&
                        ps.Id != specification.Id &&
                        ps.Version == specificationData.Version,
                        cancellationToken);

                if (existingWithSameVersion != null)
                {
                    throw new DomainException(
                        $"Спецификация с версией '{specificationData.Version}' уже существует для этого продукта");
                }

                specification.Version = specificationData.Version;
                wasUpdated = true;
            }

            // Обновляем активность если нужно
            if (specificationData.SetAsActive != specification.IsActive)
            {
                if (specificationData.SetAsActive)
                {
                    // Деактивируем другие спецификации перед активацией этой
                    await DeactivateOtherSpecificationsAsync(specification.ProductId, specification.Id, cancellationToken);
                }
                specification.IsActive = specificationData.SetAsActive;
                wasUpdated = true;
            }

            if (wasUpdated)
            {
                _specificationRepository.Update(specification);
                await _unitOfWork.CommitAsync(cancellationToken);
            }
        }

        private async Task CreateNewSpecificationAsync(
            Product product,
            ProductSpecificationData specificationData,
            CancellationToken cancellationToken)
        {
            // Проверяем уникальность версии спецификации
            if (!string.IsNullOrEmpty(specificationData.Version))
            {
                var existingVersion = await _specificationRepository.GetQueryable()
                    .FirstOrDefaultAsync(ps =>
                        ps.ProductId == product.Id &&
                        ps.Version == specificationData.Version,
                        cancellationToken);

                if (existingVersion != null)
                {
                    throw new DomainException(
                        $"Спецификация с версией '{specificationData.Version}' уже существует для этого продукта");
                }
            }

            // Деактивируем предыдущие активные спецификации если нужно
            if (specificationData.SetAsActive)
            {
                await DeactivateOtherSpecificationsAsync(product.Id, null, cancellationToken);
            }

            // Проверяем все компоненты спецификации
            foreach (var item in specificationData.Items)
            {
                var componentProduct = await _productRepository.GetByIdAsync(item.ProductId);
                if (componentProduct == null)
                {
                    throw new DomainException($"Компонент с ID {item.ProductId} не найден");
                }

                if (!ValidateComponent(product, componentProduct))
                {
                    throw new DomainException(
                        $"Недопустимый компонент {componentProduct.Name} ({componentProduct.ProductType}) " +
                        $"для продукта {product.Name} ({product.ProductType})");
                }
            }

            // Создаем спецификацию
            var specification = new ProductSpecification(
                product.Id,
                specificationData.Version,
                specificationData.SetAsActive);

            await _specificationRepository.AddAsync(specification);
            await _unitOfWork.CommitAsync(cancellationToken);

            // Создаем элементы спецификации
            foreach (var item in specificationData.Items)
            {
                var specificationItem = new ProductSpecificationItem(
                    specification.Id, item.ProductId, item.Quantity);
                await _specificationItemRepository.AddAsync(specificationItem);
            }
        }

        private async Task DeactivateOtherSpecificationsAsync(int productId, int? excludeSpecificationId, CancellationToken cancellationToken)
        {
            var query = _specificationRepository.GetQueryable()
                .Where(ps => ps.ProductId == productId && ps.IsActive);

            if (excludeSpecificationId.HasValue)
            {
                query = query.Where(ps => ps.Id != excludeSpecificationId.Value);
            }

            var activeSpecifications = await query.ToListAsync(cancellationToken);

            foreach (var activeSpec in activeSpecifications)
            {
                activeSpec.IsActive = false;
                _specificationRepository.Update(activeSpec);
            }
        }

        private async Task DeactivateSpecificationAsync(ProductSpecification specification, CancellationToken cancellationToken)
        {
            specification.IsActive = false;
            _specificationRepository.Update(specification);
            await _unitOfWork.CommitAsync(cancellationToken);
        }


        private static bool ValidateComponent(Product mainProduct, Product componentProduct)
        {
            return mainProduct.ProductType switch
            {
                // Сырье не может иметь компонентов
                ProductTypeEnum.RawMaterial => false,

                // Полуфабрикат может содержать только сырье
                ProductTypeEnum.SemiFinished =>
                    componentProduct.ProductType == ProductTypeEnum.RawMaterial,

                // Сложный полуфабрикат может содержать сырье и простые полуфабрикаты
                ProductTypeEnum.ComplexSemiFinished =>
                    componentProduct.ProductType == ProductTypeEnum.RawMaterial ||
                    componentProduct.ProductType == ProductTypeEnum.SemiFinished,

                // Готовая продукция может содержать все типы компонентов, кроме другой готовой продукции
                ProductTypeEnum.FinishedProduct =>
                    componentProduct.ProductType != ProductTypeEnum.FinishedProduct,

                _ => false
            };
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Products\Handlers\GetAllProductsQueryHandler.cs
================================================================================

using AutoMapper;
using AutoMapper.QueryableExtensions;
using CubArt.Application.Common.Behaviors;
using CubArt.Application.Common.Models;
using CubArt.Application.Products.DTOs;
using CubArt.Application.Products.Queries;
using CubArt.Domain.Entities;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Common;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Application.Products.Handlers
{
    public class GetAllProductsQueryHandler : IRequestHandler<GetAllProductsQuery, Result<PagedListDto<ProductDto>>>
    {
        private readonly IRepository<Product, int> _productRepository;
        private readonly IMapper _mapper;

        private readonly Dictionary<string, Func<IQueryable<Product>, IQueryable<Product>>> _sortMap = new()
        {
            ["name"] = q => q.OrderBy(p => p.Name),
            ["producttype"] = q => q.OrderBy(p => p.ProductType),
            ["unitofmeasure"] = q => q.OrderBy(p => p.UnitOfMeasure)
        };

        public GetAllProductsQueryHandler(
            IRepository<Product, int> productRepository,
            IMapper mapper)
        {
            _productRepository = productRepository;
            _mapper = mapper;
        }

        public async Task<Result<PagedListDto<ProductDto>>> Handle(GetAllProductsQuery request, CancellationToken cancellationToken)
        {
            try
            {
                request.Normalize();

                var query = _productRepository.GetQueryable()
                    .Include(p => p.ProductSpecifications.Where(ps => ps.IsActive))
                    .ThenInclude(ps => ps.Items)
                    .ThenInclude(psi => psi.Product)
                    .AsQueryable();

                // Фильтрация
                query = ApplyFilters(query, request);

                // Сортировка
                query = query.ApplySorting(request.SortBy, request.SortDescending, _sortMap);

                // Проекция и пагинация
                var projectedQuery = query.ProjectTo<ProductDto>(_mapper.ConfigurationProvider);
                var result = await projectedQuery.ToPagedListAsync(request.PageNumber, request.PageSize, cancellationToken);

                return Result.Success(result);
            }
            catch (Exception ex)
            {
                return Result.Failure<PagedListDto<ProductDto>>($"Ошибка получения продукции: {ex.Message}", ex);
            }
        }

        private static IQueryable<Product> ApplyFilters(IQueryable<Product> query, GetAllProductsQuery request)
        {
            if (request.ProductType.HasValue)
            {
                query = query.Where(p => p.ProductType == request.ProductType.Value);
            }

            if (request.UnitOfMeasure.HasValue)
            {
                query = query.Where(p => p.UnitOfMeasure == request.UnitOfMeasure.Value);
            }

            return query;
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Products\Handlers\GetProductByIdQueryHandler.cs
================================================================================

using AutoMapper;
using CubArt.Application.Common.Models;
using CubArt.Application.Products.DTOs;
using CubArt.Application.Products.Queries;
using CubArt.Domain.Entities;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Common;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Application.Products.Handlers
{
    public class GetProductByIdQueryHandler : IRequestHandler<GetProductByIdQuery, Result<ProductDto>>
    {
        private readonly IRepository<Product, int> _productRepository;
        private readonly IMapper _mapper;

        public GetProductByIdQueryHandler(
            IRepository<Product, int> productRepository,
            IMapper mapper)
        {
            _productRepository = productRepository;
            _mapper = mapper;
        }

        public async Task<Result<ProductDto>> Handle(GetProductByIdQuery request, CancellationToken cancellationToken)
        {
            try
            {
                var query = _productRepository.GetQueryable()
                    .Include(p => p.ProductSpecifications.Where(ps => ps.IsActive))
                    .ThenInclude(ps => ps.Items)
                    .ThenInclude(psi => psi.Product);

                var product = await query.FirstOrDefaultAsync(p => p.Id == request.Id);

                if (product is null)
                {
                    throw new NotFoundException(nameof(Product), request.Id);
                }

                var result = _mapper.Map<ProductDto>(product);

                return Result.Success(result);
            }
            catch (Exception ex)
            {
                return Result.Failure<ProductDto>($"Ошибка получения продукции: {ex.Message}", ex);
            }
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Products\Queries\GetAllProductsQuery.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Products.DTOs;
using CubArt.Domain.Enums;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Products.Queries
{
    public class GetAllProductsQuery : BaseQuery, IRequest<Result<PagedListDto<ProductDto>>>
    {
        public ProductTypeEnum? ProductType { get; set; }
        public UnitOfMeasureEnum? UnitOfMeasure { get; set; }

        protected override string DefaultSortBy => "name";

    }

    // Validator
    public class GetAllProductsQueryValidator : AbstractValidator<GetAllProductsQuery>
    {
        public GetAllProductsQueryValidator()
        {
            RuleFor(x => x.ProductType).IsInEnum().When(x => x.ProductType.HasValue);
            RuleFor(x => x.UnitOfMeasure).IsInEnum().When(x => x.UnitOfMeasure.HasValue);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Products\Queries\GetProductByIdQuery.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Products.DTOs;
using MediatR;

namespace CubArt.Application.Products.Queries
{
    public record GetProductByIdQuery(int Id) : IRequest<Result<ProductDto>>;
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Purchases\Commands\CreateOrUpdatePurchaseCommand.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Purchases.DTOs;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Purchases.Commands
{
    public class CreateOrUpdatePurchaseCommand : IRequest<Result<PurchaseDto>>
    {
        public Guid? Id { get; init; }
        public int SupplierId { get; set; }
        public int FacilityId { get; set; }
        public int ProductId { get; set; }
        public decimal Amount { get; set; }
        public decimal Quantity { get; set; }
    }

    // Validator
    public class CreateOrUpdatePurchaseCommandValidator : AbstractValidator<CreateOrUpdatePurchaseCommand>
    {
        public CreateOrUpdatePurchaseCommandValidator()
        {
            RuleFor(x => x.SupplierId).GreaterThan(0);
            RuleFor(x => x.FacilityId).GreaterThan(0);
            RuleFor(x => x.ProductId).GreaterThan(0);
            RuleFor(x => x.Amount).GreaterThan(0);
            RuleFor(x => x.Quantity).GreaterThan(0);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Purchases\Commands\DeletePurchaseByIdCommand.cs
================================================================================

using CubArt.Application.Common.Models;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Purchases.Commands
{
    public class DeletePurchaseByIdCommand : IRequest<Result>
    {
        public Guid Id { get; init; }
    }

    // Validator
    public class DeletePurchaseCommandValidator : AbstractValidator<DeletePurchaseByIdCommand>
    {
        public DeletePurchaseCommandValidator()
        {
            RuleFor(x => x.Id).NotNull();
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Purchases\DTOs\PurchaseDto.cs
================================================================================

using CubArt.Domain.Enums;

namespace CubArt.Application.Purchases.DTOs
{
    public class PurchaseDto
    {
        public Guid Id { get; set; }
        public string SupplierName { get; set; }
        public string ProductName { get; set; }
        public string FacilityName { get; set; }
        public decimal Amount { get; set; }
        public decimal Quantity { get; set; }
        public PurchaseStatusEnum PurchaseStatus { get; set; }
        public DateTime DateCreated { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Purchases\Handlers\CreateOrUpdatePurchaseCommandHandler.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Purchases.Commands;
using CubArt.Application.Purchases.DTOs;
using CubArt.Domain.Entities;
using CubArt.Domain.Enums;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Common;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Purchases.Handlers
{
    public class CreateOrUpdatePurchaseCommandHandler : IRequestHandler<CreateOrUpdatePurchaseCommand, Result<PurchaseDto>>
    {
        private readonly IPurchaseRepository _purchaseRepository;
        private readonly IRepository<Product, int> _productRepository;
        private readonly IRepository<Supplier, int> _suppliertRepository;
        private readonly IRepository<Facility, int> _facilityRepository;
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMediator _mediator;

        public CreateOrUpdatePurchaseCommandHandler(
            IPurchaseRepository purchaseRepository,
            IRepository<Product, int> productRepository,
            IRepository<Supplier, int> suppliertRepository,
            IRepository<Facility, int> facilityRepository,
            IUnitOfWork unitOfWork,
            IMediator mediator)
        {
            _purchaseRepository = purchaseRepository;
            _productRepository = productRepository;
            _suppliertRepository = suppliertRepository;
            _facilityRepository = facilityRepository;
            _unitOfWork = unitOfWork;
            _mediator = mediator;
        }

        public async Task<Result<PurchaseDto>> Handle(CreateOrUpdatePurchaseCommand request, CancellationToken cancellationToken)
        {
            try
            {
                // Проверяем существование сырья
                var product = await _productRepository.GetByIdAsync(request.ProductId);
                if (product == null)
                {
                    throw new NotFoundException(nameof(Product), request.ProductId);
                }

                if (product.ProductType != ProductTypeEnum.RawMaterial)
                {
                    return Result.Failure<PurchaseDto>($"Закупки доступны только для сырья");
                }

                // Проверяем существование поставщика
                var supplier = await _suppliertRepository.GetByIdAsync(request.SupplierId);
                if (supplier == null)
                {
                    throw new NotFoundException(nameof(Supplier), request.SupplierId);
                }
                // Проверяем существование производства
                var facility = await _facilityRepository.GetByIdAsync(request.FacilityId);
                if (facility == null)
                {
                    throw new NotFoundException(nameof(Facility), request.FacilityId);
                }

                Guid? purchaseId;
                if (request.Id is null)
                {
                    // Создание заказа
                    var purchase = new Purchase(
                        request.ProductId,
                        request.SupplierId,
                        request.FacilityId,
                        request.Amount,
                        request.Quantity);

                    await _purchaseRepository.AddAsync(purchase);
                    purchaseId = purchase.Id;
                }
                else
                {
                    // Обновление заказа
                    var purchase = await _purchaseRepository.GetByIdAsync(request.Id.Value);
                    if (purchase == null)
                    {
                        throw new NotFoundException(nameof(Purchase), request.Id.Value);
                    }

                    if (purchase.PurchaseStatus == PurchaseStatusEnum.Completed)
                    {
                        return Result.Failure<PurchaseDto>($"Ошибка при сохранении закупки: Закупку в статусе 'Завершена' запрещено редактировать");
                    }

                    purchase.UpdateEntity(
                        request.ProductId,
                        request.SupplierId,
                        request.FacilityId,
                        request.Amount,
                        request.Quantity);

                    _purchaseRepository.Update(purchase);
                    purchaseId = purchase.Id;
                }
                await _unitOfWork.CommitAsync(cancellationToken);

                return await _mediator.Send(new GetPurchaseByIdQuery(purchaseId.Value), cancellationToken);
            }
            catch (DomainException ex)
            {
                return Result.Failure<PurchaseDto>($"Ошибка при сохранении закупки: {ex.Message}");
            }
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Purchases\Handlers\DeletePurchaseByIdCommandHandler.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Payments.DTOs;
using CubArt.Application.Purchases.Commands;
using CubArt.Application.Purchases.DTOs;
using CubArt.Domain.Entities;
using CubArt.Domain.Enums;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Purchases.Handlers
{
    public class DeletePurchaseByIdCommandHandler : IRequestHandler<DeletePurchaseByIdCommand, Result>
    {
        private readonly IPurchaseRepository _purchaseRepository;
        private readonly IUnitOfWork _unitOfWork;

        public DeletePurchaseByIdCommandHandler(
            IPurchaseRepository purchaseRepository,
            IUnitOfWork unitOfWork)
        {
            _purchaseRepository = purchaseRepository;
            _unitOfWork = unitOfWork;
        }

        public async Task<Result> Handle(DeletePurchaseByIdCommand request, CancellationToken cancellationToken)
        {
            try
            {
                var purchase = await _purchaseRepository.GetByIdAsync(request.Id);
                if (purchase == null)
                {
                    throw new NotFoundException(nameof(Purchase), request.Id);
                }

                var deniedStatuses = new PurchaseStatusEnum[] { PurchaseStatusEnum.Completed, PurchaseStatusEnum.Paid };
                if (deniedStatuses.Contains(purchase.PurchaseStatus))
                {
                    return Result.Failure<PaymentDto>($"Ошибка при удалении закупки: Данная закупка оплачена");
                }

                _purchaseRepository.Delete(purchase);
                await _unitOfWork.CommitAsync(cancellationToken);

                return Result.Success();
            }
            catch (DomainException ex)
            {
                return Result.Failure<PurchaseDto>($"Ошибка при удалении закупки: {ex.Message}");
            }
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Purchases\Handlers\GetAllPurchasesQueryHandler.cs
================================================================================

using AutoMapper;
using AutoMapper.QueryableExtensions;
using CubArt.Application.Common.Behaviors;
using CubArt.Application.Common.Models;
using CubArt.Application.Purchases.Commands;
using CubArt.Application.Purchases.DTOs;
using CubArt.Domain.Entities;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Purchases.Handlers
{
    public class GetAllPurchasesQueryHandler : IRequestHandler<GetAllPurchasesQuery, Result<PagedListDto<PurchaseDto>>>
    {
        private readonly IPurchaseRepository _purchaseRepository;
        private readonly IMapper _mapper;

        private readonly Dictionary<string, Func<IQueryable<Purchase>, IQueryable<Purchase>>> _sortMap = new()
        {
            ["amount"] = q => q.OrderBy(p => p.Amount),
            ["quantity"] = q => q.OrderBy(p => p.Quantity),
            ["datecreated"] = q => q.OrderBy(p => p.DateCreated),
            ["purchasestatus"] = q => q.OrderBy(p => p.PurchaseStatus),
            ["suppliername"] = q => q.OrderBy(p => p.Supplier.Name),
            ["productname"] = q => q.OrderBy(p => p.Product.Name)
        };


        public GetAllPurchasesQueryHandler(
            IPurchaseRepository purchaseRepository,
            IMapper mapper)
        {
            _purchaseRepository = purchaseRepository;
            _mapper = mapper;
        }

        public async Task<Result<PagedListDto<PurchaseDto>>> Handle(GetAllPurchasesQuery request, CancellationToken cancellationToken)
        {
            try
            {
                request.Normalize();

                var query = _purchaseRepository.GetQueryable()
                    .AsQueryable();

                // Фильтрация
                query = ApplyFilters(query, request);

                // Сортировка
                query = query.ApplySorting(request.SortBy, request.SortDescending, _sortMap);

                // Проекция и пагинация
                var projectedQuery = query.ProjectTo<PurchaseDto>(_mapper.ConfigurationProvider);
                var result = await projectedQuery.ToPagedListAsync(request.PageNumber, request.PageSize, cancellationToken);

                return Result.Success(result);
            }
            catch (Exception ex)
            {
                return Result.Failure<PagedListDto<PurchaseDto>>($"Ошибка получения закупок: {ex.Message}", ex);
            }
        }

        private static IQueryable<Purchase> ApplyFilters(IQueryable<Purchase> query, GetAllPurchasesQuery request)
        {
            if (request.SupplierId.HasValue)
            {
                query = query.Where(p => p.SupplierId == request.SupplierId.Value);
            }

            if (request.FacilityId.HasValue)
            {
                query = query.Where(p => p.FacilityId == request.FacilityId.Value);
            }

            if (request.ProductId.HasValue)
            {
                query = query.Where(p => p.ProductId == request.ProductId.Value);
            }

            if (request.PurchaseStatus.HasValue)
            {
                query = query.Where(p => p.PurchaseStatus == request.PurchaseStatus.Value);
            }

            if (request.StartDate.HasValue)
            {
                query = query.Where(p => p.DateCreated >= request.StartDate.Value);
            }

            if (request.EndDate.HasValue)
            {
                query = query.Where(p => p.DateCreated <= request.EndDate.Value);
            }

            return query;
        }

    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Purchases\Handlers\GetPurchaseByIdQueryHandler.cs
================================================================================

using AutoMapper;
using CubArt.Application.Common.Models;
using CubArt.Application.Purchases.Commands;
using CubArt.Application.Purchases.DTOs;
using CubArt.Domain.Entities;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Purchases.Handlers
{
    public class GetPurchaseByIdQueryHandler : IRequestHandler<GetPurchaseByIdQuery, Result<PurchaseDto>>
    {
        private readonly IPurchaseRepository _purchaseRepository;
        private readonly IMapper _mapper;

        public GetPurchaseByIdQueryHandler(
            IPurchaseRepository purchaseRepository,
            IMapper mapper)
        {
            _purchaseRepository = purchaseRepository;
            _mapper = mapper;
        }

        public async Task<Result<PurchaseDto>> Handle(GetPurchaseByIdQuery request, CancellationToken cancellationToken)
        {
            try
            {
                var purchase = await _purchaseRepository.GetByIdAsync(request.Id, includeRelated: true);
                if (purchase is null)
                {
                    throw new NotFoundException(nameof(Purchase), request.Id);
                }

                return Result.Success(_mapper.Map<PurchaseDto>(purchase));
            }
            catch (Exception ex)
            {
                return Result.Failure<PurchaseDto>($"Ошибка получения закупки: {ex.Message}", ex);
            }
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Purchases\Queries\GetAllPurchasesQuery.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Purchases.DTOs;
using CubArt.Domain.Enums;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Purchases.Commands
{
    public class GetAllPurchasesQuery : BaseDateFilterQuery, IRequest<Result<PagedListDto<PurchaseDto>>>
    {
        public int? SupplierId { get; set; }
        public int? FacilityId { get; set; }
        public int? ProductId { get; set; }
        public PurchaseStatusEnum? PurchaseStatus { get; set; }

        protected override string DefaultSortBy => "datecreated";

    }

    // Validator
    public class GetAllPurchasesQueryValidator : AbstractValidator<GetAllPurchasesQuery>
    {
        public GetAllPurchasesQueryValidator()
        {
            RuleFor(x => x.PurchaseStatus).IsInEnum().When(x => x.PurchaseStatus.HasValue);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Purchases\Queries\GetPurchaseByIdQuery.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Purchases.DTOs;
using MediatR;

namespace CubArt.Application.Purchases.Commands
{
    public record GetPurchaseByIdQuery(Guid Id) : IRequest<Result<PurchaseDto>>;
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\StockBalanceViews\DTOs\StockBalanceViewDto.cs
================================================================================

using CubArt.Domain.Enums;

namespace CubArt.Application.StockBalances.DTOs
{
    public class StockBalanceViewDto
    {
        public string FacilityName { get; set; }
        public string ProductName { get; set; }
        public ProductTypeEnum ProductType { get; set; }
        public UnitOfMeasureEnum UnitOfMeasure { get; set; }
        public decimal StartBalance { get; set; }
        public decimal IncomeBalance { get; set; }
        public decimal OutcomeBalance { get; set; }
        public decimal FinishBalance { get; set; }
        public DateTime BalanceDate { get; set; }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\StockBalanceViews\Handlers\GetAllStockBalanceViewsQueryHandler.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.StockBalances.DTOs;
using CubArt.Application.StockBalances.Queries;
using CubArt.Domain.Entities;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Common;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.StockBalances.Handlers
{
    public class GetAllStockBalanceViewsQueryHandler : IRequestHandler<GetAllStockBalanceViewsQuery, Result<PagedListDto<StockBalanceViewDto>>>
    {
        private readonly IDapperService _dapperService;
        private readonly IRepository<Product, int> _productRepository;
        private readonly IRepository<Facility, int> _facilityRepository;

        public GetAllStockBalanceViewsQueryHandler(
            IDapperService dapperService,
            IRepository<Product, int> productRepository,
            IRepository<Facility, int> facilityRepository)
        {
            _dapperService = dapperService;
            _productRepository = productRepository;
            _facilityRepository = facilityRepository;
        }

        public async Task<Result<PagedListDto<StockBalanceViewDto>>> Handle(GetAllStockBalanceViewsQuery request, CancellationToken cancellationToken)
        {
            try
            {
                request.Normalize();

                // Проверяем существование производтсва
                if (request.FacilityId.HasValue)
                {
                    var facility = await _facilityRepository.GetByIdAsync(request.FacilityId.Value);
                    if (facility == null)
                    {
                        throw new NotFoundException(nameof(Facility), request.FacilityId);
                    }
                }

                // Проверяем существование продукции
                if (request.ProductId.HasValue)
                {
                    var product = await _productRepository.GetByIdAsync(request.ProductId.Value);
                    if (product == null)
                    {
                        throw new NotFoundException(nameof(Product), request.ProductId);
                    }
                }

                // Получаем общее количество записей
                var countSql = @"
                    SELECT COUNT(*)
                    FROM facility f
                    CROSS JOIN product p
                    LEFT JOIN (
                        SELECT DISTINCT ON (facility_id, product_id) 
                            facility_id, 
                            product_id, 
                            finish_balance
                        FROM stock_balance 
                        WHERE date_created < @balanceDate
                        ORDER BY facility_id, product_id, date_created DESC
                    ) lb ON lb.facility_id = f.id AND lb.product_id = p.id
                    LEFT JOIN (
                        SELECT 
                            facility_id,
                            product_id,
                            COALESCE(SUM(CASE WHEN operation_type = 1 THEN quantity ELSE 0 END), 0) as income,
                            COALESCE(SUM(CASE WHEN operation_type = 2 THEN quantity ELSE 0 END), 0) as outcome
                        FROM stock_movement 
                        WHERE DATE(date_created) = DATE(@balanceDate)
                        GROUP BY facility_id, product_id
                    ) dm ON dm.facility_id = f.id AND dm.product_id = p.id
                    WHERE 
                      (@facilityId IS NULL OR f.id = @facilityId) AND
                      (@productId IS NULL OR p.id = @productId) AND
                      (@productType IS NULL OR p.product_type = @productType) AND
                      (COALESCE(lb.finish_balance, 0) != 0 OR COALESCE(dm.income, 0) != 0 OR COALESCE(dm.outcome, 0) != 0)";

                // Основной запрос с сортировкой и пагинацией
                var orderByClause = GetOrderByClause(request.SortBy, request.SortDescending);
                var mainSql = $@"
                    WITH last_balances AS (
                        SELECT DISTINCT ON (facility_id, product_id) 
                            facility_id, 
                            product_id, 
                            finish_balance
                        FROM stock_balance 
                        WHERE date_created < @balanceDate
                        ORDER BY facility_id, product_id, date_created DESC
                    ),
                    day_movements AS (
                        SELECT 
                            facility_id,
                            product_id,
                            COALESCE(SUM(CASE WHEN operation_type = 1 THEN quantity ELSE 0 END), 0) as income,
                            COALESCE(SUM(CASE WHEN operation_type = 2 THEN quantity ELSE 0 END), 0) as outcome
                        FROM stock_movement 
                        WHERE DATE(date_created) = DATE(@balanceDate)
                        GROUP BY facility_id, product_id
                    )
                    SELECT 
                        f.name as FacilityName,
                        p.name as ProductName,
                        p.product_type as ProductType,
                        p.unit_of_measure as UnitOfMeasure,
                        COALESCE(lb.finish_balance, 0) as StartBalance,
                        COALESCE(dm.income, 0) as IncomeBalance,
                        COALESCE(dm.outcome, 0) as OutcomeBalance,
                        COALESCE(lb.finish_balance, 0) + COALESCE(dm.income, 0) - COALESCE(dm.outcome, 0) as FinishBalance,
                        DATE(@balanceDate) as BalanceDate
                    FROM facility f
                    CROSS JOIN product p
                    LEFT JOIN last_balances lb ON lb.facility_id = f.id AND lb.product_id = p.id
                    LEFT JOIN day_movements dm ON dm.facility_id = f.id AND dm.product_id = p.id
                    WHERE 
                      (@facilityId IS NULL OR f.id = @facilityId) AND
                      (@productId IS NULL OR p.id = @productId) AND
                      (@productType IS NULL OR p.product_type = @productType) AND
                      (COALESCE(lb.finish_balance, 0) != 0 OR COALESCE(dm.income, 0) != 0 OR COALESCE(dm.outcome, 0) != 0)
                    {orderByClause}
                    LIMIT @pageSize OFFSET @offset";

                // Создаем параметры
                var parameters = new
                {
                    balanceDate = request.BalanceDate,
                    facilityId = request.FacilityId,
                    productId = request.ProductId,
                    productType = request.ProductType.HasValue ? (int)request.ProductType.Value : (int?)null,
                    pageSize = request.PageSize,
                    offset = (request.PageNumber - 1) * request.PageSize
                };

                // Получаем общее количество
                var totalCount = await _dapperService.ExecuteScalarAsync<int>(countSql, parameters);

                // Получаем данные с пагинацией
                var items = await _dapperService.QueryAsync<StockBalanceViewDto>(mainSql, parameters);

                var result = PagedListDto<StockBalanceViewDto>.Create(items.ToList(), totalCount, request.PageNumber, request.PageSize);

                return Result.Success(result);
            }
            catch (Exception ex)
            {
                return Result.Failure<PagedListDto<StockBalanceViewDto>>($"Ошибка получения остатков: {ex.Message}", ex);
            }
        }

        private string GetOrderByClause(string sortBy, bool sortDescending)
        {
            var direction = sortDescending ? "DESC" : "ASC";

            var orderBy = sortBy?.ToLower() switch
            {
                "facilityname" => "f.name",
                "productname" => "p.name",
                "producttype" => "p.product_type",
                "unitofmeasure" => "p.unit_of_measure",
                "startbalance" => "StartBalance",
                "incomebalance" => "IncomeBalance",
                "outcomebalance" => "OutcomeBalance",
                "finishbalance" => "FinishBalance",
                "balancedate" => "BalanceDate",
                _ => "p.name" // сортировка по умолчанию
            };

            return $"ORDER BY {orderBy} {direction}";
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\StockBalanceViews\Queries\GetAllStockBalanceViewsQuery.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.StockBalances.DTOs;
using CubArt.Domain.Enums;
using FluentValidation;
using MediatR;

namespace CubArt.Application.StockBalances.Queries
{
    public class GetAllStockBalanceViewsQuery : BaseQuery, IRequest<Result<PagedListDto<StockBalanceViewDto>>>
    {
        public int? FacilityId { get; set; }
        public int? ProductId { get; set; }
        public ProductTypeEnum? ProductType { get; set; }
        public DateTime BalanceDate { get; set; }
        protected override string DefaultSortBy => "productname";

        public override void Normalize()
        {
            base.Normalize();

            // Если дата не указана, используем текущую дату
            if (BalanceDate == default)
            {
                BalanceDate = DateTime.UtcNow.Date;
            }
            else
            {
                BalanceDate = BalanceDate.Kind == DateTimeKind.Unspecified
                    ? DateTime.SpecifyKind(BalanceDate, DateTimeKind.Utc)
                    : BalanceDate.ToUniversalTime();
            }
        }

    }

    // Validator
    public class GetAllStockBalancesQueryValidator : AbstractValidator<GetAllStockBalanceViewsQuery>
    {
        public GetAllStockBalancesQueryValidator()
        {
            RuleFor(x => x.ProductType).IsInEnum().When(x => x.ProductType.HasValue);
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Supplies\Commands\CreateOrUpdateSupplyCommand.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Supplies.DTOs;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Supplies.Commands
{
    public class CreateOrUpdateSupplyCommand : IRequest<Result<SupplyDto>>
    {
        public Guid? Id { get; init; }
        public Guid PurchaseId { get; set; }
        public decimal Quantity { get; set; }
    }

    // Validator
    public class CreateOrUpdateSupplyCommandValidator : AbstractValidator<CreateOrUpdateSupplyCommand>
    {
        public CreateOrUpdateSupplyCommandValidator()
        {
            RuleFor(x => x.PurchaseId).NotEmpty();
            RuleFor(x => x.Quantity).GreaterThan(0);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Supplies\Commands\DeleteSupplyByIdCommand.cs
================================================================================

using CubArt.Application.Common.Models;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Supplies.Commands
{
    public class DeleteSupplyByIdCommand : IRequest<Result>
    {
        public Guid Id { get; init; }
    }

    // Validator
    public class DeleteSupplyByIdCommandValidator : AbstractValidator<DeleteSupplyByIdCommand>
    {
        public DeleteSupplyByIdCommandValidator()
        {
            RuleFor(x => x.Id).NotEmpty();
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Supplies\DTOs\SupplyDto.cs
================================================================================

using CubArt.Application.Common.Models;

namespace CubArt.Application.Supplies.DTOs
{
    public class SupplyDto : BaseActionDto
    {
        public Guid Id { get; set; }
        public Guid PurchaseId { get; set; }
        public decimal Quantity { get; set; }
        public DateTime DateCreated { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Supplies\Handlers\CreateOrUpdateSupplyCommandHandler.cs
================================================================================

using AutoMapper;
using CubArt.Application.Common.Models;
using CubArt.Application.Supplies.Commands;
using CubArt.Application.Supplies.DTOs;
using CubArt.Domain.Entities;
using CubArt.Domain.Enums;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Common;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using CubArt.Infrastructure.Models;
using MediatR;

namespace CubArt.Application.Supplies.Handlers
{
    public class CreateOrUpdateSupplyCommandHandler : IRequestHandler<CreateOrUpdateSupplyCommand, Result<SupplyDto>>
    {
        private readonly ISupplyRepository _supplyRepository;
        private readonly IPurchaseRepository _purchaseRepository;
        private readonly IRepository<StockMovement, Guid> _stockMovementRepository;
        private readonly IStockMovementService _stockMovementService;
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;

        public CreateOrUpdateSupplyCommandHandler(
            ISupplyRepository supplyRepository,
            IPurchaseRepository purchaseRepository,
            IRepository<StockMovement, Guid> stockMovementRepository,
            IStockMovementService stockMovementService,
            IUnitOfWork unitOfWork,
            IMapper mapper)
        {
            _supplyRepository = supplyRepository;
            _purchaseRepository = purchaseRepository;
            _stockMovementRepository = stockMovementRepository;
            _stockMovementService = stockMovementService;
            _unitOfWork = unitOfWork;
            _mapper = mapper;
        }

        public async Task<Result<SupplyDto>> Handle(CreateOrUpdateSupplyCommand request, CancellationToken cancellationToken)
        {
            using var transaction = await _unitOfWork.BeginTransactionAsync(cancellationToken);

            try
            {
                // Проверяем существование закупки
                var purchase = await _purchaseRepository.GetByIdAsync(request.PurchaseId);
                if (purchase == null)
                {
                    throw new NotFoundException(nameof(Purchase), request.PurchaseId);
                }
                if (purchase.PurchaseStatus == PurchaseStatusEnum.Completed)
                {
                    await _unitOfWork.RollbackTransactionAsync(transaction, cancellationToken);
                    return Result.Failure<SupplyDto>($"Ошибка при сохранении поставки: Закупка данной поставки в статусе 'Завершена'");
                }

                var supplyId = request.Id;
                // Проверяем, не превышает ли количество оставшееся
                var totalQuantity = await _supplyRepository.GetTotalIncomeQuantityAsync(request.PurchaseId, supplyId);
                var remainingQuantity = purchase.Quantity - totalQuantity;

                if (request.Quantity > remainingQuantity)
                {
                    await _unitOfWork.RollbackTransactionAsync(transaction, cancellationToken);
                    return Result.Failure<SupplyDto>($"Количество в поставке {request.Quantity} превосходит оставшееся {remainingQuantity}");
                }

                Supply? supply;
                if (supplyId is null)
                {
                    // Создаем поставку
                    supply = new Supply(request.PurchaseId, request.Quantity);

                    await _supplyRepository.AddAsync(supply);
                    await _unitOfWork.CommitAsync(cancellationToken);

                    // Создаем движение запасов
                    var movement = new StockMovement(
                        facilityId: purchase.FacilityId,
                        productId: purchase.ProductId,
                        operationType: OperationTypeEnum.Income,
                        referenceType: StockMovemetReferenceTypeEnum.Supply,
                        referenceId: supply.Id.ToString(),
                        quantity: request.Quantity,
                        dateCreated: supply.DateCreated);

                    await _stockMovementRepository.AddAsync(movement);
                }
                else
                {
                    // Обновление поставки
                    supply = await _supplyRepository.GetByIdAsync(supplyId.Value);
                    if (supply == null)
                    {
                        throw new NotFoundException(nameof(Supply), supplyId.Value);
                    }

                    supply.UpdateEntity(
                        request.PurchaseId,
                        request.Quantity
                    );

                    _supplyRepository.Update(supply);

                    await _stockMovementService.UpdateStockMovementsAndRecalculateBalances(
                        new UpdateStockMovementsAndRecalculateBalancesModel(
                            supply.Id,
                            OperationTypeEnum.Income,
                            StockMovemetReferenceTypeEnum.Supply,
                            supply.DateCreated,
                            purchase.FacilityId,
                            purchase.ProductId,
                            request.Quantity
                        )                        
                    );
                }

                // Если поставка полная, то переводим статус закупки
                if (remainingQuantity - request.Quantity == 0)
                {
                    purchase.PurchaseStatus = PurchaseStatusEnum.Completed;
                    _purchaseRepository.Update(purchase);
                }

                await _unitOfWork.CommitAsync(cancellationToken);
                await _unitOfWork.CommitTransactionAsync(transaction, cancellationToken);

                // Получаем полные данные для ответа
                var fullSupply = await _supplyRepository.GetByIdAsync(supply.Id);

                return Result.Success(_mapper.Map<SupplyDto>(fullSupply));
            }
            catch (Exception ex)
            {
                await _unitOfWork.RollbackTransactionAsync(transaction, cancellationToken);
                return Result.Failure<SupplyDto>($"Ошибка при создании поставки: {ex.Message}", ex);
            }
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Supplies\Handlers\DeleteSupplyByIdCommandHandler.cs
================================================================================

using AutoMapper;
using CubArt.Application.Common.Models;
using CubArt.Application.Supplies.Commands;
using CubArt.Application.Supplies.DTOs;
using CubArt.Domain.Entities;
using CubArt.Domain.Enums;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Common;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Supplies.Handlers
{
    public class DeleteSupplyByIdCommandHandler : IRequestHandler<DeleteSupplyByIdCommand, Result>
    {
        private readonly ISupplyRepository _supplyRepository;
        private readonly IPurchaseRepository _purchaseRepository;
        private readonly IStockMovementService _stockMovementService;
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;

        public DeleteSupplyByIdCommandHandler(
            ISupplyRepository supplyRepository,
            IPurchaseRepository purchaseRepository,
            IStockMovementService stockMovementService,
            IUnitOfWork unitOfWork,
            IMapper mapper)
        {
            _supplyRepository = supplyRepository;
            _purchaseRepository = purchaseRepository;
            _stockMovementService = stockMovementService;
            _unitOfWork = unitOfWork;
            _mapper = mapper;
        }

        public async Task<Result> Handle(DeleteSupplyByIdCommand request, CancellationToken cancellationToken)
        {
            using var transaction = await _unitOfWork.BeginTransactionAsync(cancellationToken);

            try
            {
                // Проверяем существование поставки
                var supply = await _supplyRepository.GetByIdAsync(request.Id);
                if (supply == null)
                {
                    throw new NotFoundException(nameof(Supply), request.Id);
                }

                // Проверяем закупку
                var purchase = await _purchaseRepository.GetByIdAsync(supply.PurchaseId);
                if (purchase == null)
                {
                    throw new NotFoundException(nameof(Purchase), supply.PurchaseId);
                }
                if (purchase.PurchaseStatus == PurchaseStatusEnum.Completed)
                {
                    await _unitOfWork.RollbackTransactionAsync(transaction, cancellationToken);
                    return Result.Failure<SupplyDto>($"Ошибка при удалении поставки: Закупка данной поставки в статусе 'Завершена'");
                }

                _supplyRepository.Delete(supply);

                // Удаляем движения запасов
                await _stockMovementService.DeleteStockMovements(supply.Id, StockMovemetReferenceTypeEnum.Supply);

                // Пересчет балансов
                await _stockMovementService.RecalculateAllBalancesFromDate(supply.DateCreated.Date, purchase.FacilityId, purchase.ProductId);

                await _unitOfWork.CommitAsync(cancellationToken);
                await _unitOfWork.CommitTransactionAsync(transaction, cancellationToken);

                return Result.Success();
            }
            catch (Exception ex)
            {
                await _unitOfWork.RollbackTransactionAsync(transaction, cancellationToken);
                return Result.Failure<SupplyDto>($"Ошибка при удалении поставки: {ex.Message}", ex);
            }
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Supplies\Handlers\GetAllSuppliesQueryHandler.cs
================================================================================

using AutoMapper;
using AutoMapper.QueryableExtensions;
using CubArt.Application.Common.Behaviors;
using CubArt.Application.Common.Models;
using CubArt.Application.Supplies.DTOs;
using CubArt.Application.Supplies.Queries;
using CubArt.Domain.Entities;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Supplies.Handlers
{
    public class GetAllSuppliesQueryHandler : IRequestHandler<GetAllSuppliesQuery, Result<PagedListDto<SupplyDto>>>
    {
        private readonly ISupplyRepository _supplyRepository;
        private readonly IMapper _mapper;

        private readonly Dictionary<string, Func<IQueryable<Supply>, IQueryable<Supply>>> _sortMap = new()
        {
            ["quantity"] = q => q.OrderBy(p => p.Quantity),
            ["datecreated"] = q => q.OrderBy(p => p.DateCreated)
        };


        public GetAllSuppliesQueryHandler(
            ISupplyRepository supplyRepository,
            IMapper mapper)
        {
            _supplyRepository = supplyRepository;
            _mapper = mapper;
        }

        public async Task<Result<PagedListDto<SupplyDto>>> Handle(GetAllSuppliesQuery request, CancellationToken cancellationToken)
        {
            try
            {
                request.Normalize();

                var query = _supplyRepository.GetQueryable()
                    .AsQueryable();

                // Фильтрация
                query = ApplyFilters(query, request);

                // Сортировка
                query = query.ApplySorting(request.SortBy, request.SortDescending, _sortMap);

                // Проекция и пагинация
                var projectedQuery = query.ProjectTo<SupplyDto>(_mapper.ConfigurationProvider);
                var result = await projectedQuery.ToPagedListAsync(request.PageNumber, request.PageSize, cancellationToken);

                return Result.Success(result);
            }
            catch (Exception ex)
            {
                return Result.Failure<PagedListDto<SupplyDto>>($"Ошибка получения поставок: {ex.Message}", ex);
            }
        }

        private static IQueryable<Supply> ApplyFilters(IQueryable<Supply> query, GetAllSuppliesQuery request)
        {
            if (request.PurchaseId.HasValue)
            {
                query = query.Where(p => p.PurchaseId == request.PurchaseId.Value);
            }

            if (request.StartDate.HasValue)
            {
                query = query.Where(p => p.DateCreated >= request.StartDate.Value);
            }

            if (request.EndDate.HasValue)
            {
                query = query.Where(p => p.DateCreated <= request.EndDate.Value);
            }

            return query;
        }

    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Supplies\Handlers\GetSupplyByIdQueryHandler.cs
================================================================================

using AutoMapper;
using CubArt.Application.Common.Models;
using CubArt.Application.Supplies.DTOs;
using CubArt.Application.Supplies.Queries;
using CubArt.Domain.Enums;
using CubArt.Domain.Exceptions;
using CubArt.Infrastructure.Interfaces;
using MediatR;
using static StackExchange.Redis.Role;

namespace CubArt.Application.Supplies.Handlers
{
    public class GetSupplyByIdQueryHandler : IRequestHandler<GetSupplyByIdQuery, Result<SupplyDto>>
    {
        private readonly ISupplyRepository _supplyRepository;
        private readonly IStockMovementService _stockMovementService;
        private readonly IMapper _mapper;

        public GetSupplyByIdQueryHandler(
            ISupplyRepository supplyRepository,
            IStockMovementService stockMovementService,
            IMapper mapper)
        {
            _supplyRepository = supplyRepository;
            _stockMovementService = stockMovementService;
            _mapper = mapper;
        }

        public async Task<Result<SupplyDto>> Handle(GetSupplyByIdQuery request, CancellationToken cancellationToken)
        {
            try
            {
                var supply = await _supplyRepository.GetByIdAsync(request.Id);
                if (supply is null)
                {
                    throw new NotFoundException(nameof(supply), request.Id);
                }

                var dto = _mapper.Map<SupplyDto>(supply);
                var stockMovements = await _stockMovementService.GetStockMovementsByReference(supply.Id.ToString(), StockMovemetReferenceTypeEnum.Supply);
                dto.StockMovementList = _mapper.Map<IEnumerable<StockMovementDto>>(stockMovements);

                return Result.Success(dto);
            }
            catch (Exception ex)
            {
                return Result.Failure<SupplyDto>($"Ошибка получения поставки: {ex.Message}", ex);
            }
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Supplies\Queries\GetAllSuppliesQuery.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Supplies.DTOs;
using MediatR;

namespace CubArt.Application.Supplies.Queries
{
    public class GetAllSuppliesQuery : BaseDateFilterQuery, IRequest<Result<PagedListDto<SupplyDto>>>
    {
        public Guid? PurchaseId { get; set; }

        protected override string DefaultSortBy => "datecreated";

    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Supplies\Queries\GetSupplyByIdQuery.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Supplies.DTOs;
using MediatR;

namespace CubArt.Application.Supplies.Queries
{
    public record GetSupplyByIdQuery(Guid Id) : IRequest<Result<SupplyDto>>;
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Users\Commands\ChangePasswordCommand.cs
================================================================================

using CubArt.Application.Common.Models;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Users.Commands
{
    public class ChangePasswordCommand : IRequest<Result>
    {
        public string CurrentPassword { get; set; }
        public string NewPassword { get; set; }
    }

    // Validator
    public class ChangePasswordCommandValidator : AbstractValidator<ChangePasswordCommand>
    {
        public ChangePasswordCommandValidator()
        {
            RuleFor(x => x.CurrentPassword)
                .NotEmpty()
                .MinimumLength(6)
                .MaximumLength(100);

            RuleFor(x => x.NewPassword)
                .NotEmpty()
                .MinimumLength(6)
                .MaximumLength(100)
                .Must((command, newPassword) => newPassword != command.CurrentPassword)
                .WithMessage("Новый пароль должен отличаться от текущего");
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Users\Commands\CreateUserCommand.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Users.DTOs;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Users.Commands
{
    public class CreateUserCommand : IRequest<Result<UserDto>>
    {
        public string Username { get; set; }
        public string Email { get; set; }
        public string Password { get; set; }
        public string? FirstName { get; set; }
        public string? LastName { get; set; }
    }

    // Validator
    public class CreateUserCommandValidator : AbstractValidator<CreateUserCommand>
    {
        public CreateUserCommandValidator()
        {
            RuleFor(x => x.Username)
                .NotEmpty()
                .MaximumLength(50)
                .Matches("^[a-zA-Z0-9_]+$")
                .WithMessage("Имя пользователя может содержать только буквы, цифры и подчеркивания");

            RuleFor(x => x.Email)
                .NotEmpty()
                .EmailAddress()
                .MaximumLength(255);

            RuleFor(x => x.Password)
                .NotEmpty()
                .MinimumLength(6)
                .MaximumLength(100);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Users\Commands\LoginCommand.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Users.DTOs;
using FluentValidation;
using MediatR;

namespace CubArt.Application.Users.Commands
{
    public class LoginCommand : IRequest<Result<LoginDto>>
    {
        public string Username { get; set; }
        public string Password { get; set; }
    }

    // Validator
    public class LoginCommandValidator : AbstractValidator<LoginCommand>
    {
        public LoginCommandValidator()
        {
            RuleFor(x => x.Username).NotNull();
            RuleFor(x => x.Password).NotNull();
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Users\DTOs\LoginDto.cs
================================================================================

namespace CubArt.Application.Users.DTOs
{
    public class LoginDto
    {
        public string Token { get; set; }
        public UserDto User { get; set; }
        public DateTime ExpiresAt { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Users\DTOs\UserDto.cs
================================================================================

namespace CubArt.Application.Users.DTOs
{
    public class UserDto
    {
        public Guid Id { get; set; }
        public string Username { get; set; }
        public string Email { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public bool IsActive { get; set; }
        public DateTime DateCreated { get; set; }
        public DateTime? LastLogin { get; set; }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Users\Handlers\ChangePasswordCommandHandler.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Common.Services;
using CubArt.Application.Users.Commands;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Users.Handlers
{
    public class ChangePasswordCommandHandler : IRequestHandler<ChangePasswordCommand, Result>
    {
        private readonly IUserRepository _userRepository;
        private readonly IAuthService _authService;
        private readonly IUnitOfWork _unitOfWork;

        public ChangePasswordCommandHandler(
            IUserRepository userRepository,
            IAuthService authService,
            IUnitOfWork unitOfWork)
        {
            _userRepository = userRepository;
            _authService = authService;
            _unitOfWork = unitOfWork;
        }

        public async Task<Result> Handle(ChangePasswordCommand request, CancellationToken cancellationToken)
        {
            try
            {
                var currentUserId = await _authService.GetCurrentUserIdAsync();

                // Находим пользователя
                var user = await _userRepository.GetByIdAsync(currentUserId);
                if (user == null)
                {
                    return Result.Failure("Пользователь не найден");
                }

                if (!user.IsActive)
                {
                    return Result.Failure("Учетная запись пользователя деактивирована");
                }

                // Проверяем текущий пароль
                if (!_authService.VerifyPassword(request.CurrentPassword, user.PasswordHash))
                {
                    return Result.Failure("Текущий пароль указан неверно");
                }

                // Хешируем новый пароль
                var newPasswordHash = _authService.HashPassword(request.NewPassword);

                // Обновляем пароль
                user.ChangePassword(newPasswordHash);
                _userRepository.Update(user);

                await _unitOfWork.CommitAsync(cancellationToken);

                return Result.Success();
            }
            catch (Exception ex)
            {
                return Result.Failure($"Ошибка при смене пароля: {ex.Message}", ex);
            }
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Users\Handlers\CreateUserCommandHandler.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Common.Services;
using CubArt.Application.Users.Commands;
using CubArt.Application.Users.DTOs;
using CubArt.Domain.Entities;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Users.Handlers
{
    public class CreateUserCommandHandler : IRequestHandler<CreateUserCommand, Result<UserDto>>
    {
        private readonly IUserRepository _userRepository;
        private readonly IAuthService _authService;
        private readonly IUnitOfWork _unitOfWork;

        public CreateUserCommandHandler(
            IUserRepository userRepository,
            IAuthService authService,
            IUnitOfWork unitOfWork)
        {
            _userRepository = userRepository;
            _authService = authService;
            _unitOfWork = unitOfWork;
        }

        public async Task<Result<UserDto>> Handle(CreateUserCommand request, CancellationToken cancellationToken)
        {
            try
            {
                // Проверяем уникальность username
                if (await _userRepository.UsernameExistsAsync(request.Username))
                {
                    return Result.Failure<UserDto>($"Пользователь с именем '{request.Username}' уже существует");
                }

                // Проверяем уникальность email
                if (await _userRepository.EmailExistsAsync(request.Email))
                {
                    return Result.Failure<UserDto>($"Пользователь с email '{request.Email}' уже существует");
                }

                // Хешируем пароль
                var passwordHash = _authService.HashPassword(request.Password);

                // Создаем пользователя
                var user = new User(
                    request.Username,
                    request.Email,
                    passwordHash,
                    request.FirstName,
                    request.LastName
                );

                await _userRepository.AddAsync(user);
                await _unitOfWork.CommitAsync(cancellationToken);

                var userDto = new UserDto
                {
                    Id = user.Id,
                    Username = user.Username,
                    Email = user.Email,
                    FirstName = user.FirstName,
                    LastName = user.LastName,
                    IsActive = user.IsActive,
                    DateCreated = user.DateCreated,
                    LastLogin = user.LastLogin
                };

                return Result.Success(userDto);
            }
            catch (Exception ex)
            {
                return Result.Failure<UserDto>($"Ошибка при создании пользователя: {ex.Message}", ex);
            }
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Application\Users\Handlers\LoginCommandHandler.cs
================================================================================

using CubArt.Application.Common.Models;
using CubArt.Application.Common.Services;
using CubArt.Application.Users.Commands;
using CubArt.Application.Users.DTOs;
using CubArt.Infrastructure.Interfaces;
using MediatR;

namespace CubArt.Application.Users.Handlers
{
    public class LoginCommandHandler : IRequestHandler<LoginCommand, Result<LoginDto>>
    {
        private readonly IUserRepository _userRepository;
        private readonly IAuthService _authService;

        public LoginCommandHandler(IUserRepository userRepository, IAuthService authService)
        {
            _userRepository = userRepository;
            _authService = authService;
        }

        public async Task<Result<LoginDto>> Handle(LoginCommand request, CancellationToken cancellationToken)
        {
            try
            {
                var user = await _userRepository.GetByUsernameAsync(request.Username);
                if (user == null || !user.IsActive)
                {
                    return Result.Failure<LoginDto>("Неверное имя пользователя или пароль");
                }

                if (!_authService.VerifyPassword(request.Password, user.PasswordHash))
                {
                    return Result.Failure<LoginDto>("Неверное имя пользователя или пароль");
                }

                // Обновляем время последнего входа
                user.UpdateLastLogin();
                _userRepository.Update(user);

                var userDto = new UserDto
                {
                    Id = user.Id,
                    Username = user.Username,
                    Email = user.Email,
                    FirstName = user.FirstName,
                    LastName = user.LastName,
                    IsActive = user.IsActive,
                    DateCreated = user.DateCreated,
                    LastLogin = user.LastLogin
                };

                var token = _authService.GenerateJwtToken(userDto);

                var response = new LoginDto
                {
                    Token = token,
                    User = userDto,
                    ExpiresAt = DateTime.UtcNow.AddDays(7)
                };

                return Result.Success(response);
            }
            catch (Exception ex)
            {
                return Result.Failure<LoginDto>($"Ошибка при входе: {ex.Message}", ex);
            }
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Common\Entity.cs
================================================================================

using CubArt.Domain.Events;

namespace CubArt.Domain.Common
{
    // Базовые классы для доменных сущностей
    public abstract class Entity<T>: IEntity
    {
        public T Id { get; protected set; }

        private readonly List<DomainEvent> _domainEvents = new();
        public IReadOnlyCollection<DomainEvent> DomainEvents => _domainEvents.AsReadOnly();

        public void AddDomainEvent(DomainEvent eventItem)
        {
            _domainEvents.Add(eventItem);
        }

        public void RemoveDomainEvent(DomainEvent eventItem)
        {
            _domainEvents.Remove(eventItem);
        }

        public void ClearDomainEvents()
        {
            _domainEvents.Clear();
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Common\IEntity.cs
================================================================================

using CubArt.Domain.Events;

namespace CubArt.Domain.Common
{
    public interface IEntity
    {
        IReadOnlyCollection<DomainEvent> DomainEvents { get; }
        void AddDomainEvent(DomainEvent eventItem);
        void RemoveDomainEvent(DomainEvent eventItem);
        void ClearDomainEvents();
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\Facility.cs
================================================================================

using CubArt.Domain.Common;

namespace CubArt.Domain.Entities
{
    public class Facility : Entity<int>
    {
        public string Name { get; set; }
        public string? Address { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\IHasCreatedDate.cs
================================================================================

namespace CubArt.Domain.Entities
{
    public interface IHasCreatedDate
    {
        DateTime DateCreated { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\Payment.cs
================================================================================

using CubArt.Domain.Common;
using CubArt.Domain.Enums;
using CubArt.Domain.Events;

namespace CubArt.Domain.Entities
{
    public class Payment : Entity<Guid>, IHasCreatedDate
    {
        public Payment(Guid purchaseId, decimal amount, PaymentMethodEnum paymentMethod)
        {
            PurchaseId = purchaseId;
            Amount = amount;
            PaymentMethod = paymentMethod;
            PaymentStatus = PaymentStatusEnum.Completed;

            AddDomainEvent(new PaymentCreatedEvent(this));
        }

        public void UpdateEntity(Guid purchaseId, decimal amount, PaymentMethodEnum paymentMethod)
        {
            PurchaseId = purchaseId;
            Amount = amount;
            PaymentMethod = paymentMethod;
        }

        public Guid PurchaseId { get; set; }
        public decimal Amount { get; set; }
        public PaymentMethodEnum PaymentMethod { get; set; }
        public PaymentStatusEnum PaymentStatus { get; set; }
        public string? Сomment { get; set; }
        public DateTime DateCreated { get; set; }

        // Навигационные свойства
        public virtual Purchase Purchase { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\Product.cs
================================================================================

using CubArt.Domain.Common;
using CubArt.Domain.Enums;

namespace CubArt.Domain.Entities
{
    public class Product : Entity<int>
    {
        public Product(string name, ProductTypeEnum productType, UnitOfMeasureEnum unitOfMeasure)
        {
            Name = name;
            ProductType = productType;
            UnitOfMeasure = unitOfMeasure;
        }

        public string Name { get; set; }
        public ProductTypeEnum ProductType { get; set; }
        public UnitOfMeasureEnum UnitOfMeasure { get; set; }

        // Навигационные свойства
        public virtual ICollection<ProductSpecification> ProductSpecifications { get; set; } = new List<ProductSpecification>();
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\Production.cs
================================================================================

using CubArt.Domain.Common;

namespace CubArt.Domain.Entities
{
    public class Production : Entity<Guid>, IHasCreatedDate
    {
        public Production(int productId, int facilityId, decimal quantity)
        {
            Id = Guid.NewGuid();
            ProductId = productId;
            FacilityId = facilityId;
            Quantity = quantity;
        }

        public void UpdateEntity(int productId, int facilityId, decimal quantity)
        {
            ProductId = productId;
            FacilityId = facilityId;
            Quantity = quantity;
        }

        public int ProductId { get; set; }
        public int FacilityId { get; set; }
        public decimal Quantity { get; set; }
        public DateTime DateCreated { get; set; }

        // Навигационные свойства
        public virtual Product Product { get; set; }
        public virtual Facility Facility { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\ProductSpecification.cs
================================================================================

using CubArt.Domain.Common;

namespace CubArt.Domain.Entities
{
    public class ProductSpecification : Entity<int>, IHasCreatedDate
    {
        public ProductSpecification(int productId, string? version, bool isActive) 
        {
            ProductId = productId;
            Version = version;
            IsActive = isActive;
        }

        public int ProductId { get; set; }
        public string? Version { get; set; }
        public bool IsActive { get; set; }
        public DateTime DateCreated { get; set; }

        // Навигационные свойства
        public virtual Product Product { get; set; }
        public virtual ICollection<ProductSpecificationItem> Items { get; set; } = new List<ProductSpecificationItem>();
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\ProductSpecificationItem.cs
================================================================================

using CubArt.Domain.Common;

namespace CubArt.Domain.Entities
{
    public class ProductSpecificationItem : Entity<int>
    {
        public ProductSpecificationItem(int productSpecificationId, int productId, decimal quantity) 
        {
            ProductSpecificationId = productSpecificationId;
            ProductId = productId;
            Quantity = quantity;
        }

        public int ProductSpecificationId { get; set; }
        public int ProductId { get; set; }
        public decimal Quantity { get; set; }

        // Навигационные свойства
        public virtual ProductSpecification ProductSpecification { get; set; }
        public virtual Product Product { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\Purchase.cs
================================================================================

using CubArt.Domain.Common;
using CubArt.Domain.Enums;
using CubArt.Domain.Events;

namespace CubArt.Domain.Entities
{
    public class Purchase : Entity<Guid>, IHasCreatedDate
    {
        public Purchase(int productId, int supplierId, int facilityId, decimal amount, decimal quantity)
        {
            ProductId = productId;
            SupplierId = supplierId;
            FacilityId = facilityId;
            Amount = amount;
            Quantity = quantity;
            PurchaseStatus = PurchaseStatusEnum.Pending;

            AddDomainEvent(new PurchaseCreatedEvent(this));
        }

        public void UpdateEntity(int productId, int supplierId, int facilityId, decimal amount, decimal quantity)
        {
            ProductId = productId;
            SupplierId = supplierId;
            FacilityId = facilityId;
            Amount = amount;
            Quantity = quantity;
        }

        public int SupplierId { get; set; }
        public int ProductId { get; set; }
        public int FacilityId { get; set; }
        public decimal Amount { get; set; }
        public decimal Quantity { get; set; }
        public PurchaseStatusEnum PurchaseStatus { get; set; }
        public DateTime DateCreated { get; set; }

        // Навигационные свойства
        public virtual Supplier Supplier { get; set; }
        public virtual Product Product { get; set; }
        public virtual Facility Facility { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\Role.cs
================================================================================

using CubArt.Domain.Common;

namespace CubArt.Domain.Entities
{
    public class Role : Entity<int>
    {
        public Role(string name, string? description)
        {
            Name = name;
            Description = description;
        }

        public string Name { get; private set; }
        public string? Description { get; private set; }

        // Навигационные свойства
        public virtual ICollection<UserRole> UserRoles { get; set; } = new List<UserRole>();
        public virtual ICollection<RolePermission> RolePermissions { get; set; } = new List<RolePermission>();
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\RolePermission.cs
================================================================================

using CubArt.Domain.Common;
using CubArt.Domain.Enums;

namespace CubArt.Domain.Entities
{
    public class RolePermission : Entity<int>
    {
        public RolePermission(int roleId, PermissionEnum permission)
        {
            RoleId = roleId;
            Permission = permission;
        }

        public int RoleId { get; private set; }
        public PermissionEnum Permission { get; private set; }

        // Навигационные свойства
        public virtual Role Role { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\StockBalance.cs
================================================================================

using CubArt.Domain.Common;

namespace CubArt.Domain.Entities
{
    public class StockBalance : Entity<Guid>, IHasCreatedDate
    {
        public StockBalance(
            int facilityId,
            int productId,
            decimal startBalance,
            decimal incomeBalance,
            decimal outcomeBalance,
            decimal finishBalance,
            DateTime dateCreated)
        {
            FacilityId = facilityId;
            ProductId = productId;
            StartBalance = startBalance;
            IncomeBalance = incomeBalance;
            OutcomeBalance = outcomeBalance;
            FinishBalance = finishBalance;
            DateCreated = dateCreated;
        }

        public void UpdateBalances(decimal startBalance, decimal income, decimal outcome, decimal finishBalance)
        {
            StartBalance = startBalance;
            IncomeBalance = income;
            OutcomeBalance = outcome;
            FinishBalance = finishBalance;
        }

        public int FacilityId { get; set; }
        public int ProductId { get; set; }
        public decimal StartBalance { get; set; }
        public decimal IncomeBalance { get; set; }
        public decimal OutcomeBalance { get; set; }
        public decimal FinishBalance { get; set; }
        public DateTime DateCreated { get; set; }

        // Навигационные свойства
        public virtual Facility Facility { get; set; }
        public virtual Product Product { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\StockBalanceView.cs
================================================================================

using CubArt.Domain.Enums;

namespace CubArt.Domain.Entities
{
    public class StockBalanceView
    {
        public string FacilityName { get; set; }
        public string ProductName { get; set; }
        public ProductTypeEnum ProductType { get; set; }
        public UnitOfMeasureEnum UnitOfMeasure { get; set; }
        public decimal StartBalance { get; set; }
        public decimal IncomeBalance { get; set; }
        public decimal OutcomeBalance { get; set; }
        public decimal FinishBalance { get; set; }
        public DateTime BalanceDate { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\StockMovement.cs
================================================================================

using CubArt.Domain.Common;
using CubArt.Domain.Enums;

namespace CubArt.Domain.Entities
{
    public class StockMovement : Entity<Guid>, IHasCreatedDate
    {
        public StockMovement(
            int facilityId,
            int productId,
            OperationTypeEnum operationType,
            StockMovemetReferenceTypeEnum referenceType,
            string referenceId,
            decimal quantity,
            DateTime dateCreated)
        {
            FacilityId = facilityId;
            ProductId = productId;
            OperationType = operationType;
            ReferenceType = referenceType;
            ReferenceId = referenceId;
            Quantity = quantity;
            DateCreated = dateCreated;
        }

        public void UpdateEntity(
            int facilityId,
            int productId,
            OperationTypeEnum operationType,
            StockMovemetReferenceTypeEnum referenceType,
            string referenceId,
            decimal quantity,
            DateTime date)
        {
            FacilityId = facilityId;
            ProductId = productId;
            OperationType = operationType;
            ReferenceType = referenceType;
            ReferenceId = referenceId;
            Quantity = quantity;
            DateCreated = date;
        }

        public int FacilityId { get; set; }
        public int ProductId { get; set; }
        public OperationTypeEnum OperationType { get; set; }
        public StockMovemetReferenceTypeEnum ReferenceType { get; set; }
        public string ReferenceId { get; set; }
        public decimal Quantity { get; set; }
        public DateTime DateCreated { get; set; }

        // Навигационные свойства
        public virtual Facility Facility { get; set; }
        public virtual Product Product { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\Supplier.cs
================================================================================

using CubArt.Domain.Common;

namespace CubArt.Domain.Entities
{
    public class Supplier : Entity<int>
    {
        public string Name { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\Supply.cs
================================================================================

using CubArt.Domain.Common;

namespace CubArt.Domain.Entities
{
    public class Supply : Entity<Guid>, IHasCreatedDate
    {
        public Supply(Guid purchaseId, decimal quantity)
        {
            Id = Guid.NewGuid();
            PurchaseId = purchaseId;
            Quantity = quantity;
        }

        public void UpdateEntity(Guid purchaseId, decimal quantity)
        {
            PurchaseId = purchaseId;
            Quantity = quantity;
        }

        public Guid PurchaseId { get; set; }
        public decimal Quantity { get; set; }
        public DateTime DateCreated { get; set; }

        // Навигационные свойства
        public virtual Purchase Purchase { get; set; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\SystemLog.cs
================================================================================

using CubArt.Domain.Common;

namespace CubArt.Domain.Entities
{
    public class SystemLog : Entity<Guid>, IHasCreatedDate
    {
        public SystemLog(
            string level, 
            string message, 
            string? userId = null,
            string? ipAddress = null,
            string? userAgent = null,
            string? requestPath = null,
            string? requestMethod = null,
            string? exceptionType = null,
            string? source = null,
            string? action = null,
            string? entityType = null,
            string? entityId = null,
            string? additionalData = null
            )
        {
            Level = level;
            Message = message;
            UserId = userId;
            IpAddress = ipAddress;
            UserAgent = userAgent;
            RequestPath = requestPath;
            RequestMethod = requestMethod;
            ExceptionType = exceptionType;
            Source = source;
            Action = action;
            EntityType = entityType;
            EntityId = entityId;
            AdditionalData = additionalData;
        }

        public string Level { get; private set; }
        public string Message { get; private set; }
        public string? UserId { get; private set; }
        public string? IpAddress { get; private set; }
        public string? UserAgent { get; private set; }
        public string? RequestPath { get; private set; }
        public string? RequestMethod { get; private set; }
        public string? ExceptionType { get; private set; }
        public string? Source { get; private set; }
        public string? Action { get; private set; }
        public string? EntityType { get; private set; }
        public string? EntityId { get; private set; }
        public string? AdditionalData { get; private set; }
        public DateTime DateCreated { get; set; }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\User.cs
================================================================================

using CubArt.Domain.Common;
using CubArt.Domain.Enums;

namespace CubArt.Domain.Entities
{
    public class User : Entity<Guid>, IHasCreatedDate
    {
        public User(string username, string email, string passwordHash, string firstName, string lastName)
        {
            Username = username;
            Email = email;
            PasswordHash = passwordHash;
            FirstName = firstName;
            LastName = lastName;
            IsActive = true;
            DateCreated = DateTime.UtcNow;
        }

        public string Username { get; private set; }
        public string Email { get; private set; }
        public string PasswordHash { get; private set; }
        public string? FirstName { get; private set; }
        public string? LastName { get; private set; }
        public bool IsActive { get; private set; }
        public DateTime DateCreated { get; set; }
        public DateTime? LastLogin { get; private set; }

        public void UpdateLastLogin()
        {
            LastLogin = DateTime.UtcNow;
        }

        public void Deactivate()
        {
            IsActive = false;
        }

        public void UpdateProfile(string firstName, string lastName, string email)
        {
            FirstName = firstName;
            LastName = lastName;
            Email = email;
        }

        public void ChangePassword(string newPasswordHash)
        {
            PasswordHash = newPasswordHash;
        }

        public void AssignRole(int roleId)
        {
            if (!UserRoles.Any(ur => ur.RoleId == roleId))
            {
                UserRoles.Add(new UserRole(Id, roleId));
            }
        }

        public void RemoveRole(int roleId)
        {
            var userRole = UserRoles.FirstOrDefault(ur => ur.RoleId == roleId);
            if (userRole != null)
            {
                UserRoles.Remove(userRole);
            }
        }

        public bool HasPermission(PermissionEnum permission)
        {
            return UserRoles.Any(ur =>
                ur.Role.RolePermissions.Any(rp => rp.Permission == permission));
        }

        public IEnumerable<PermissionEnum> GetPermissions()
        {
            return UserRoles
                .SelectMany(ur => ur.Role.RolePermissions)
                .Select(rp => rp.Permission)
                .Distinct();
        }

        public IEnumerable<string> GetRoleNames()
        {
            return UserRoles.Select(ur => ur.Role.Name).Distinct();
        }

        // Навигационные свойства
        public virtual ICollection<UserRole> UserRoles { get; set; } = new List<UserRole>();
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Entities\UserRole.cs
================================================================================

using CubArt.Domain.Common;

namespace CubArt.Domain.Entities
{
    public class UserRole : Entity<int>
    {
        public UserRole(Guid userId, int roleId)
        {
            UserId = userId;
            RoleId = roleId;
        }

        public Guid UserId { get; private set; }
        public int RoleId { get; private set; }

        // Навигационные свойства
        public virtual User User { get; set; }
        public virtual Role Role { get; set; }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Enums\OperationTypeEnum.cs
================================================================================

namespace CubArt.Domain.Enums
{
    public enum OperationTypeEnum
    {
        // Приход
        Income = 1,
        // Расход
        Outcome = 2
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Enums\PaymentMethodEnum.cs
================================================================================

namespace CubArt.Domain.Enums
{
    public enum PaymentMethodEnum
    {
        // Банковский перевод
        BankTransfer = 1,
        // Наличные
        Cash = 2,
        // Карта
        Card = 3
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Enums\PaymentStatusEnum.cs
================================================================================

namespace CubArt.Domain.Enums
{
    public enum PaymentStatusEnum
    {
        // Ожидает подтверждения
        Pending = 1,
        // Завершен
        Completed = 2,
        // Отменен
        Cancelled = 3   
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Enums\PermissionEnum.cs
================================================================================

namespace CubArt.Domain.Enums
{
    public enum PermissionEnum
    {
        // User Management
        UserRead = 1,
        UserCreate = 2,
        UserUpdate = 3,
        UserDelete = 4,

        // Product Management
        ProductRead = 5,
        ProductCreate = 6,
        ProductUpdate = 7,
        ProductDelete = 8,

        // Purchase Management
        PurchaseRead = 9,
        PurchaseCreate = 10,
        PurchaseUpdate = 11,
        PurchaseDelete = 12,

        // Payment Management
        PaymentRead = 13,
        PaymentCreate = 14,
        PaymentUpdate = 15,
        PaymentDelete = 16,

        // Supply Management
        SupplyRead = 17,
        SupplyCreate = 18,
        SupplyUpdate = 19,
        SupplyDelete = 20,

        // Production Management
        ProductionRead = 21,
        ProductionCreate = 22,
        ProductionUpdate = 23,
        ProductionDelete = 24,

        // Stock Management
        StockRead = 25,
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Enums\ProductTypeEnum.cs
================================================================================

namespace CubArt.Domain.Enums
{
    public enum ProductTypeEnum
    {
        // Сырье
        RawMaterial = 1,
        // Полуфабрикат
        SemiFinished = 2,
        // Сложный полуфабрикат
        ComplexSemiFinished = 3,
        // Готовый продукт
        FinishedProduct = 4
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Enums\PurchaseStatusEnum.cs
================================================================================

namespace CubArt.Domain.Enums
{
    public enum PurchaseStatusEnum
    {
        // Ожидает оплаты
        Pending = 1,
        // Оплачена
        Paid = 2,
        // Завершена
        Completed = 3,
        // Отменена
        Cancelled = 4
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Enums\StockMovemetReferenceTypeEnum.cs
================================================================================

namespace CubArt.Domain.Enums
{
    public enum StockMovemetReferenceTypeEnum
    {
        // Поставка сырья
        Supply = 1,
        // Производство
        Production = 2,
        // Продажа
        Sale = 3,
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Enums\UnitOfMeasureEnum.cs
================================================================================

namespace CubArt.Domain.Enums
{
    public enum UnitOfMeasureEnum
    {
        // Метры
        Meter = 1,
        // Кв. метры
        SquareMeter = 2,
        // Куб. метры
        CubicMeter = 3,
        // П. метры
        LinearMeter = 4,
        // Штуки
        Pieces = 5,
        // Киллограммы
        Kilograms = 6
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Enums\UserRoleEnum.cs
================================================================================

namespace CubArt.Domain.Enums
{
    public enum UserRoleEnum
    {
        SuperAdmin = 1,
        Admin = 2,
        Viewer = 3
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Events\DomainEvent.cs
================================================================================

using MediatR;

namespace CubArt.Domain.Events
{
    public interface IDomainEvent : INotification
    {
        DateTime OccurredOn { get; }
    }

    public abstract class DomainEvent : IDomainEvent
    {
        public DateTime OccurredOn { get; protected set; } = DateTime.UtcNow;
        public string EventType { get; protected set; }

        protected DomainEvent()
        {
            EventType = GetType().Name;
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Events\LogEvent.cs
================================================================================

namespace CubArt.Domain.Events
{
    public abstract class LogEvent : DomainEvent
    {
        public string Level { get; protected set; }
        public string Message { get; protected set; }
        public string? UserId { get; set; }
        public string? IpAddress { get; set; }
        public string? UserAgent { get; set; }
        public Dictionary<string, object>? AdditionalData { get; set; }
    }

    public class InformationLogEvent : LogEvent
    {
        public InformationLogEvent(string message, Dictionary<string, object>? additionalData = null)
        {
            Level = "Information";
            Message = message;
            AdditionalData = additionalData;
        }
    }

    public class WarningLogEvent : LogEvent
    {
        public WarningLogEvent(string message, Dictionary<string, object>? additionalData = null)
        {
            Level = "Warning";
            Message = message;
            AdditionalData = additionalData;
        }
    }

    public class ErrorLogEvent : LogEvent
    {
        public string? StackTrace { get; set; }
        public string? ExceptionType { get; set; }

        public ErrorLogEvent(string message, Exception? ex = null, Dictionary<string, object>? additionalData = null)
        {
            Level = "Error";
            Message = message;
            AdditionalData = additionalData;

            if (ex != null)
            {
                StackTrace = ex.StackTrace;
                ExceptionType = ex.GetType().Name;
            }
        }
    }

    // Бизнес-события логирования
    public class PurchaseCreatedLogEvent : InformationLogEvent
    {
        public Guid PurchaseId { get; }
        public int SupplierId { get; set; }
        public int ProductId { get; set; }
        public int FacilityId { get; set; }
        public decimal Amount { get; set; }
        public decimal Quantity { get; set; }

        public PurchaseCreatedLogEvent(Guid purchaseId, int supplierId, int productId, int facilityId, decimal amount, decimal quantity)
            : base($"Создана закупка #purchaseId={purchaseId} supplierId={supplierId}, productId={productId}, facilityId={facilityId}, amount={amount}, quantity={quantity}")
        {
            PurchaseId = purchaseId;
            SupplierId = supplierId;
            ProductId = productId;
            FacilityId = facilityId;
            Amount = amount;
            Quantity = quantity;
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Events\Payment.cs
================================================================================

using CubArt.Domain.Entities;

namespace CubArt.Domain.Events
{
    public class PaymentCreatedEvent : DomainEvent
    {
        public PaymentCreatedEvent(Payment payment)
        {
            Payment = payment;
        }

        public Payment Payment { get; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Events\Purchase.cs
================================================================================

using CubArt.Domain.Entities;

namespace CubArt.Domain.Events
{
    public class PurchaseCreatedEvent : DomainEvent
    {
        public PurchaseCreatedEvent(Purchase order)
        {
            Purchase = order;
        }

        public Purchase Purchase { get; }
    }

    public class RawMaterialStockIncreasedEvent : DomainEvent
    {
        public RawMaterialStockIncreasedEvent(int productId, decimal quantity, int facilityId)
        {
            ProductId = productId;
            Quantity = quantity;
            FacilityId = facilityId;
        }

        public int ProductId { get; }
        public decimal Quantity { get; }
        public int FacilityId { get; }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Exceptions\DomainException.cs
================================================================================

namespace CubArt.Domain.Exceptions
{
    public class DomainException : Exception
    {
        public DomainException(string message) : base(message)
        {
        }

        public DomainException(string message, Exception innerException) : base(message, innerException)
        {
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Exceptions\ExceptionExtention.cs
================================================================================

using System.Text;

namespace CubArt.Domain.Exceptions
{
    public static class ExceptionExtensions
    {
        public static string GetFullExceptionDetails(this Exception exception)
        {
            var sb = new StringBuilder();
            var currentException = exception;
            var level = 0;

            while (currentException != null)
            {
                sb.AppendLine($"Level {level}: {currentException.GetType().Name}");
                sb.AppendLine($"Message: {currentException.Message}");
                sb.AppendLine($"StackTrace: {currentException.StackTrace}");
                sb.AppendLine("---");

                currentException = currentException.InnerException;
                level++;
            }

            return sb.ToString();
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Domain\Exceptions\NotFoundException.cs
================================================================================

namespace CubArt.Domain.Exceptions
{
    public class NotFoundException : DomainException
    {
        public string EntityName { get; }
        public object EntityId { get; }

        public NotFoundException(string entityName, object entityId)
            : base($"{entityName} с ID {entityId} не найден")
        {
            EntityName = entityName;
            EntityId = entityId;
        }

        public NotFoundException(string message) : base(message)
        {
        }

        public NotFoundException(string message, Exception innerException)
            : base(message, innerException)
        {
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\DependencyInjection.cs
================================================================================

using CubArt.Infrastructure.Caching;
using CubArt.Infrastructure.Common;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using CubArt.Infrastructure.Repositories;
using CubArt.Infrastructure.Services;
using MediatR;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using StackExchange.Redis;

namespace CubArt.Infrastructure
{
    public static class DependencyInjection
    {
        public static IServiceCollection AddInfrastructureLayer(this IServiceCollection services, IConfiguration configuration)
        {
            // Redis cache
            services.AddSingleton<IConnectionMultiplexer>(sp =>
            ConnectionMultiplexer.Connect(configuration.GetConnectionString("RedisConnection")));

            services.AddScoped<IRedisCacheService, RedisCacheService>();

            // Database
            services.AddDbContext<AppDbContext>(builder =>
            {
                builder.UseNpgsql(configuration.GetConnectionString("DBConnectionString"), 
                    options => options.UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery));
                builder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
            });

            // Log
            services.AddDbContext<LogDbContext>(builder =>
            {
                builder.UseNpgsql(configuration.GetConnectionString("DBConnectionString"));
                builder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
            }, ServiceLifetime.Scoped);

            // Repositories
            services.AddScoped(typeof(IRepository<,>), typeof(Repository<,>));
            services.AddScoped<IPurchaseRepository, PurchaseRepository>();
            services.AddScoped<IProductRepository, ProductRepository>();
            services.AddScoped<IPaymentRepository, PaymentRepository>();
            services.AddScoped<ISupplyRepository, SupplyRepository>();
            services.AddScoped<IProductionRepository, ProductionRepository>();
            services.AddScoped<IUserRepository, UserRepository>();
            services.AddScoped<ISystemLogRepository, SystemLogRepository>();

            // Services
            services.AddScoped<IStockMovementService, StockMovementService>();
            services.AddScoped<IDapperService, DapperService>();

            // Unit of Work
            services.AddScoped<IUnitOfWork, UnitOfWork>();

            return services;
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Caching\CacheKeys.cs
================================================================================

using CubArt.Domain.Enums;

namespace CubArt.Infrastructure.Caching
{
    public static class CacheKeys
    {
        // Продукция
        public static string Product(int id) => $"product:{id}";
        public static string ProductsList(string filter) => $"products:list:{filter}";

        // Справочники
        public static string Suppliers => "suppliers:all";
        public static string Facilities => "facilities:all";
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Caching\CacheSettings.cs
================================================================================

namespace CubArt.Infrastructure.Caching
{
    public static class CacheSettings
    {
        // Продукция
        public static readonly TimeSpan ProductDetails = TimeSpan.FromMinutes(30);
        public static readonly TimeSpan ProductList = TimeSpan.FromMinutes(15);

        // Общие настройки
        public static readonly TimeSpan Default = TimeSpan.FromMinutes(20);
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Caching\RedisCacheService .cs
================================================================================

using StackExchange.Redis;
using System.Text.Json;

namespace CubArt.Infrastructure.Caching
{
    public interface IRedisCacheService
    {
        Task<T?> GetAsync<T>(string key);
        Task SetAsync<T>(string key, T value, TimeSpan? expiry = null);
        Task RemoveAsync(string key);
        Task<bool> ExistsAsync(string key);
        Task RemoveByPatternAsync(string pattern);
    }

    public class RedisCacheService : IRedisCacheService
    {
        private readonly IConnectionMultiplexer _redis;
        private readonly IDatabase _database;

        public RedisCacheService(IConnectionMultiplexer redis)
        {
            _redis = redis;
            _database = redis.GetDatabase();
        }

        public async Task<T?> GetAsync<T>(string key)
        {
            var value = await _database.StringGetAsync(key);
            if (!value.HasValue) return default;

            return JsonSerializer.Deserialize<T>(value.ToString());
        }

        public async Task SetAsync<T>(string key, T value, TimeSpan? expiry = null)
        {
            var serializedValue = JsonSerializer.Serialize(value);
            await _database.StringSetAsync(key, serializedValue, expiry);
        }

        public async Task RemoveAsync(string key)
        {
            await _database.KeyDeleteAsync(key);
        }

        public async Task<bool> ExistsAsync(string key)
        {
            return await _database.KeyExistsAsync(key);
        }

        public async Task RemoveByPatternAsync(string pattern)
        {
            var endpoints = _redis.GetEndPoints();
            var server = _redis.GetServer(endpoints.First());
            var keys = server.Keys(pattern: pattern).ToArray();

            foreach (var key in keys)
            {
                await _database.KeyDeleteAsync(key);
            }
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Common\Repository.cs
================================================================================

using CubArt.Domain.Common;
using CubArt.Infrastructure.Data;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Infrastructure.Common
{
    // Базовый репозиторий
    public interface IRepository<T, TId> where T : Entity<TId> where TId : notnull
    {
        Task<T?> GetByIdAsync(TId id, bool includeRelated = false);
        IQueryable<T> GetQueryable();
        Task AddAsync(T entity);
        void Update(T entity);
        void Delete(T entity);
    }

    public class Repository<T, TId> : IRepository<T, TId> where T : Entity<TId> where TId : notnull
    {
        protected readonly AppDbContext _context;
        protected readonly DbSet<T> _dbSet;

        public Repository(AppDbContext context)
        {
            _context = context;
            _dbSet = context.Set<T>();
        }

        public virtual async Task<T?> GetByIdAsync(TId id, bool includeRelated = false)
        {
            var query = _dbSet.AsNoTracking();

            return await query.FirstOrDefaultAsync(e => e.Id.Equals(id));
        }

        public virtual IQueryable<T> GetQueryable()
        {
            return _dbSet.AsNoTracking().AsQueryable();
        }

        public virtual async Task AddAsync(T entity)
        {
            await _dbSet.AddAsync(entity);
        }

        public virtual void Update(T entity)
        {
            _dbSet.Update(entity);
        }

        public virtual void Delete(T entity)
        {
            _dbSet.Remove(entity);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\AppDbContext.cs
================================================================================

using CubArt.Domain.Common;
using CubArt.Domain.Entities;
using CubArt.Domain.Events;
using CubArt.Infrastructure.Data.Configurations;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Infrastructure.Data
{
    public class AppDbContext : DbContext
    {
        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options)
        {
        }

        // DbSets
        public DbSet<Purchase> Purchases { get; set; }
        public DbSet<Facility> Facilities { get; set; }
        public DbSet<Supplier> Suppliers { get; set; }
        public DbSet<Product> Products { get; set; }
        public DbSet<StockMovement> StockMovements { get; set; }
        public DbSet<StockBalance> StockBalances { get; set; }
        public DbSet<ProductSpecification> ProductSpecifications { get; set; }
        public DbSet<ProductSpecificationItem> ProductSpecificationItems { get; set; }
        public DbSet<Payment> Payments { get; set; }
        public DbSet<Supply> Supplies { get; set; }
        public DbSet<Production> Productions { get; set; }
        public DbSet<SystemLog> SystemLogs { get; set; }
        public DbSet<User> Users { get; set; }
        public DbSet<Role> Roles { get; set; }
        public DbSet<UserRole> UserRoles { get; set; }
        public DbSet<RolePermission> RolePermissions { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            // Игнорируем DomainEvent и другие не-entity классы
            modelBuilder.Ignore<DomainEvent>();

            modelBuilder.ApplyConfiguration(new PurchaseConfiguration());
            modelBuilder.ApplyConfiguration(new FacilityConfiguration());
            modelBuilder.ApplyConfiguration(new SupplierConfiguration());
            modelBuilder.ApplyConfiguration(new ProductConfiguration());
            modelBuilder.ApplyConfiguration(new StockMovementConfiguration());
            modelBuilder.ApplyConfiguration(new StockBalanceConfiguration());
            modelBuilder.ApplyConfiguration(new ProductSpecificationConfiguration());
            modelBuilder.ApplyConfiguration(new ProductSpecificationItemConfiguration());
            modelBuilder.ApplyConfiguration(new PaymentConfiguration());
            modelBuilder.ApplyConfiguration(new SupplyConfiguration());
            modelBuilder.ApplyConfiguration(new ProductionConfiguration());
            modelBuilder.ApplyConfiguration(new SystemLogConfiguration());
            modelBuilder.ApplyConfiguration(new UserConfiguration());
            modelBuilder.ApplyConfiguration(new RoleConfiguration());
            modelBuilder.ApplyConfiguration(new UserRoleConfiguration());
            modelBuilder.ApplyConfiguration(new RolePermissionConfiguration());

        }

        public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
        {
            var entries = ChangeTracker.Entries<IEntity>()
                .Where(e => e.State == EntityState.Added || e.State == EntityState.Modified);

            foreach (var entry in entries)
            {
                if (entry.State == EntityState.Added)
                {
                    if (entry.Entity is IHasCreatedDate entityWithDate && (entityWithDate.DateCreated as DateTime?) is null)
                        entityWithDate.DateCreated = DateTime.UtcNow;
                }

                if (entry.State == EntityState.Modified)
                {
                    // entry.Entity.UpdatedAt = DateTime.UtcNow;
                }
            }

            return await base.SaveChangesAsync(cancellationToken);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\LogDbContext.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Domain.Events;
using CubArt.Infrastructure.Data.Configurations;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Infrastructure.Data
{
    public class LogDbContext : DbContext
    {
        public LogDbContext(DbContextOptions<LogDbContext> options) : base(options) { }

        public DbSet<SystemLog> SystemLogs { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            // Игнорируем DomainEvent и другие не-entity классы
            modelBuilder.Ignore<DomainEvent>();

            modelBuilder.ApplyConfiguration(new SystemLogConfiguration());
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\UnitOfWork.cs
================================================================================

using CubArt.Domain.Common;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Storage;
using System.Data;

namespace CubArt.Infrastructure.Data
{
    // Unit of Work pattern
    public interface IUnitOfWork
    {
        Task CommitAsync(CancellationToken cancellationToken = default);
        void Rollback();
        Task<IDbContextTransaction> BeginTransactionAsync(CancellationToken cancellationToken = default);
        Task CommitTransactionAsync(IDbContextTransaction transaction,
            CancellationToken cancellationToken = default);
        Task RollbackTransactionAsync(IDbContextTransaction transaction,
            CancellationToken cancellationToken = default);

    }

    public class UnitOfWork : IUnitOfWork
    {
        private readonly AppDbContext _context;
        private IDbContextTransaction _currentTransaction;

        public UnitOfWork(AppDbContext context)
        {
            _context = context;
        }

        public async Task CommitAsync(CancellationToken cancellationToken = default)
        {
            // Обработка доменных событий перед сохранением
            var entities = _context.ChangeTracker.Entries<IEntity>()
                .Select(e => e.Entity)
                .Where(e => e.DomainEvents.Any())
                .ToArray();

            foreach (var entity in entities)
            {
                var events = entity.DomainEvents.ToArray();
                entity.ClearDomainEvents();

                // Здесь можно публиковать события через MediatR
                // await _mediator.Publish(events);
            }

            await _context.SaveChangesAsync(cancellationToken);
            _context.ChangeTracker.Clear();
        }

        public void Rollback()
        {
            // В EF Core обычно не нужно, но можно сбросить изменения
            _context.ChangeTracker.Entries()
                .Where(e => e.State != EntityState.Unchanged)
                .ToList()
                .ForEach(entry => entry.State = EntityState.Unchanged);
        }

        public async Task<IDbContextTransaction> BeginTransactionAsync(CancellationToken cancellationToken = default)
        {
            if (_currentTransaction != null)
            {
                throw new InvalidOperationException("Transaction already in progress");
            }

            _currentTransaction = await _context.Database.BeginTransactionAsync(cancellationToken);
            return _currentTransaction;
        }

        public async Task CommitTransactionAsync(IDbContextTransaction transaction,
            CancellationToken cancellationToken = default)
        {
            if (transaction == null)
            {
                throw new ArgumentNullException(nameof(transaction));
            }

            if (transaction != _currentTransaction)
            {
                throw new InvalidOperationException("Transaction mismatch");
            }

            try
            {
                await CommitAsync(cancellationToken);
                await transaction.CommitAsync(cancellationToken);
            }
            catch
            {
                await RollbackTransactionAsync(transaction, cancellationToken);
                throw;
            }
            finally
            {
                await DisposeTransactionAsync();
            }
        }

        public async Task RollbackTransactionAsync(IDbContextTransaction transaction,
            CancellationToken cancellationToken = default)
        {
            if (transaction == null)
            {
                throw new ArgumentNullException(nameof(transaction));
            }

            try
            {
                await transaction.RollbackAsync(cancellationToken);
            }
            finally
            {
                await DisposeTransactionAsync();
            }
        }

        private async Task DisposeTransactionAsync()
        {
            if (_currentTransaction != null)
            {
                await _currentTransaction.DisposeAsync();
                _currentTransaction = null;
            }
        }

    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\FacilityConfiguration.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Extentions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class FacilityConfiguration : IEntityTypeConfiguration<Facility>
    {
        public void Configure(EntityTypeBuilder<Facility> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(Facility));

            builder.HasBaseEntityInt();


            builder.PropertyWithUnderscore(x => x.Name).IsRequired();
            
            builder.PropertyWithUnderscore(x => x.Address);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\PaymentConfiguration.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Extentions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class PaymentConfiguration : IEntityTypeConfiguration<Payment>
    {
        public void Configure(EntityTypeBuilder<Payment> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(Payment));

            builder.HasBaseEntityGuid();
            builder.HasCreatedDateEntity();


            builder.PropertyWithUnderscore(x => x.PurchaseId).IsRequired();
            
            builder.PropertyWithUnderscore(x => x.Amount).IsRequired();
            
            builder.PropertyWithUnderscore(x => x.PaymentMethod);

            builder.PropertyWithUnderscore(x => x.PaymentStatus);

            builder.PropertyWithUnderscore(x => x.Сomment);

            // Внешние ключи
            builder.HasOne(p => p.Purchase)
                .WithMany()
                .HasForeignKey(p => p.PurchaseId)
                .OnDelete(DeleteBehavior.NoAction);

            // Индексы
            builder.HasIndexWithUnderscore(x => x.PurchaseId);

            builder.HasIndexWithUnderscore(x => x.PaymentMethod);

            builder.HasIndexWithUnderscore(x => x.PaymentStatus);

            builder.HasIndexWithUnderscore(x => x.DateCreated);

        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\ProductConfiguration.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Extentions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class ProductConfiguration : IEntityTypeConfiguration<Product>
    {
        public void Configure(EntityTypeBuilder<Product> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(Product));

            builder.HasBaseEntityInt();


            builder.PropertyWithUnderscore(x => x.Name).IsRequired();

            builder.PropertyWithUnderscore(x => x.ProductType).IsRequired();

            builder.PropertyWithUnderscore(x => x.UnitOfMeasure);

            // Внешние ключи
            builder.HasMany(p => p.ProductSpecifications)
                .WithOne(p => p.Product)
                .HasForeignKey(p => p.ProductId)
                .OnDelete(DeleteBehavior.NoAction);

            // Индексы
            builder.HasIndexWithUnderscore(x => x.Name).IsUnique();
            builder.HasIndexWithUnderscore(x => x.ProductType);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\ProductionConfiguration.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Extentions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class ProductionConfiguration : IEntityTypeConfiguration<Production>
    {
        public void Configure(EntityTypeBuilder<Production> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(Production));

            builder.HasBaseEntityGuid();
            builder.HasCreatedDateEntity();


            builder.PropertyWithUnderscore(x => x.ProductId).IsRequired();
            
            builder.PropertyWithUnderscore(x => x.FacilityId).IsRequired();

            builder.PropertyWithUnderscore(x => x.Quantity).IsRequired();

            // Внешние ключи
            builder.HasOne(p => p.Product)
                .WithMany()
                .HasForeignKey(p => p.ProductId)
                .OnDelete(DeleteBehavior.NoAction);

            // Индексы
            builder.HasIndexWithUnderscore(x => x.ProductId);

            builder.HasIndexWithUnderscore(x => x.FacilityId);

            builder.HasIndexWithUnderscore(x => x.DateCreated);

        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\ProductSpecificationConfiguration.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Extentions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class ProductSpecificationConfiguration : IEntityTypeConfiguration<ProductSpecification>
    {
        public void Configure(EntityTypeBuilder<ProductSpecification> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(ProductSpecification));

            builder.HasBaseEntityInt();
            builder.HasCreatedDateEntity();


            builder.PropertyWithUnderscore(x => x.ProductId).IsRequired();
            
            builder.PropertyWithUnderscore(x => x.Version);
            
            builder.PropertyWithUnderscore(x => x.IsActive);

            builder.PropertyWithUnderscore(x => x.DateCreated);

            // Внешние ключи
            builder.HasOne(p => p.Product)
                .WithMany(p => p.ProductSpecifications)
                .HasForeignKey(p => p.ProductId)
                .OnDelete(DeleteBehavior.NoAction);

            builder.HasMany(p => p.Items)
                .WithOne(p => p.ProductSpecification)
                .HasForeignKey(p => p.ProductSpecificationId)
                .OnDelete(DeleteBehavior.NoAction);

            // Индексы
            builder.HasIndexWithUnderscore(x => x.ProductId);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\ProductSpecificationItemConfiguration.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Extentions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class ProductSpecificationItemConfiguration : IEntityTypeConfiguration<ProductSpecificationItem>
    {
        public void Configure(EntityTypeBuilder<ProductSpecificationItem> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(ProductSpecificationItem));

            builder.HasBaseEntityInt();


            builder.PropertyWithUnderscore(x => x.ProductSpecificationId).IsRequired();
            
            builder.PropertyWithUnderscore(x => x.ProductId).IsRequired();
            
            builder.PropertyWithUnderscore(x => x.Quantity).IsRequired();

            // Внешние ключи
            builder.HasOne(p => p.ProductSpecification)
                .WithMany(p => p.Items)
                .HasForeignKey(p => p.ProductSpecificationId)
                .OnDelete(DeleteBehavior.NoAction);

            builder.HasOne(p => p.Product)
                .WithMany()
                .HasForeignKey(p => p.ProductId)
                .OnDelete(DeleteBehavior.NoAction);

            // Индексы
            builder.HasIndexWithUnderscore(x => x.ProductSpecificationId);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\PurchaseConfiguration .cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Extentions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class PurchaseConfiguration : IEntityTypeConfiguration<Purchase>
    {
        public void Configure(EntityTypeBuilder<Purchase> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(Purchase));

            builder.HasBaseEntityGuid();
            builder.HasCreatedDateEntity();


            builder.PropertyWithUnderscore(x => x.SupplierId);
            
            builder.PropertyWithUnderscore(x => x.ProductId).IsRequired();
            
            builder.PropertyWithUnderscore(x => x.FacilityId).IsRequired();

            builder.PropertyWithUnderscore(x => x.Quantity).IsRequired();

            builder.PropertyWithUnderscore(x => x.Amount).IsRequired();

            builder.PropertyWithUnderscore(x => x.PurchaseStatus);

            // Внешние ключи
            builder.HasOne(p => p.Supplier)
                .WithMany()
                .HasForeignKey(p => p.SupplierId)
                .OnDelete(DeleteBehavior.NoAction);

            builder.HasOne(p => p.Product)
                .WithMany()
                .HasForeignKey(p => p.ProductId)
                .OnDelete(DeleteBehavior.NoAction);

            builder.HasOne(p => p.Facility)
                .WithMany()
                .HasForeignKey(p => p.FacilityId)
                .OnDelete(DeleteBehavior.NoAction);

            // Индексы
            builder.HasIndexWithUnderscore(x => x.SupplierId);

            builder.HasIndexWithUnderscore(x => x.ProductId);

            builder.HasIndexWithUnderscore(x => x.FacilityId);

            builder.HasIndexWithUnderscore(x => x.DateCreated);

        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\RoleConfiguration.cs
================================================================================

using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Microsoft.EntityFrameworkCore;
using CubArt.Infrastructure.Extentions;
using CubArt.Domain.Entities;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class RoleConfiguration : IEntityTypeConfiguration<Role>
    {
        public void Configure(EntityTypeBuilder<Role> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(Role));

            builder.HasBaseEntityInt();

            builder.PropertyWithUnderscore(x => x.Name)
                .IsRequired()
                .HasMaxLength(100);

            builder.PropertyWithUnderscore(x => x.Description)
                .HasMaxLength(500);

            // Индексы
            builder.HasIndexWithUnderscore(x => x.Name)
                .IsUnique();
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\RolePermissionConfiguration.cs
================================================================================

using CubArt.Domain.Entities;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Microsoft.EntityFrameworkCore;
using CubArt.Infrastructure.Extentions;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class RolePermissionConfiguration : IEntityTypeConfiguration<RolePermission>
    {
        public void Configure(EntityTypeBuilder<RolePermission> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(RolePermission));

            builder.HasBaseEntityInt();

            builder.PropertyWithUnderscore(x => x.RoleId)
                .IsRequired();

            builder.PropertyWithUnderscore(x => x.Permission)
                .IsRequired();

            // Внешние ключи
            builder.HasOne(rp => rp.Role)
                .WithMany(r => r.RolePermissions)
                .HasForeignKey(rp => rp.RoleId)
                .OnDelete(DeleteBehavior.Cascade);

            // Индексы
            builder.HasIndex(x => new { x.RoleId, x.Permission })
                .IsUnique();
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\StockBalanceConfiguration.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Extentions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class StockBalanceConfiguration : IEntityTypeConfiguration<StockBalance>
    {
        public void Configure(EntityTypeBuilder<StockBalance> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(StockBalance));

            builder.HasBaseEntityGuid();
            builder.HasCreatedDateEntity();


            builder.PropertyWithUnderscore(x => x.FacilityId).IsRequired();
            
            builder.PropertyWithUnderscore(x => x.ProductId).IsRequired();

            builder.PropertyWithUnderscore(x => x.StartBalance);

            builder.PropertyWithUnderscore(x => x.IncomeBalance);

            builder.PropertyWithUnderscore(x => x.OutcomeBalance);

            builder.PropertyWithUnderscore(x => x.FinishBalance);

            // Внешние ключи
            builder.HasOne(p => p.Facility)
                .WithMany()
                .HasForeignKey(p => p.FacilityId)
                .OnDelete(DeleteBehavior.NoAction);

            builder.HasOne(p => p.Product)
                .WithMany()
                .HasForeignKey(p => p.ProductId)
                .OnDelete(DeleteBehavior.NoAction);

            // Индексы
            builder.HasIndexWithUnderscore(x => x.FacilityId);

            builder.HasIndexWithUnderscore(x => x.ProductId);

            builder.HasIndexWithUnderscore(x => x.DateCreated);


            builder.HasIndex(x => new { x.FacilityId, x.ProductId, x.DateCreated })
                .HasDatabaseName("idx_stock_balance_facility_id_product_id_date_created")
                .IsUnique();
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\StockMovementConfiguration.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Extentions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class StockMovementConfiguration : IEntityTypeConfiguration<StockMovement>
    {
        public void Configure(EntityTypeBuilder<StockMovement> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(StockMovement));

            builder.HasBaseEntityGuid();
            builder.HasCreatedDateEntity();


            builder.PropertyWithUnderscore(x => x.FacilityId).IsRequired();
            
            builder.PropertyWithUnderscore(x => x.ProductId).IsRequired();

            builder.PropertyWithUnderscore(x => x.OperationType).IsRequired();

            builder.PropertyWithUnderscore(x => x.Quantity).IsRequired();

            builder.PropertyWithUnderscore(x => x.ReferenceType).IsRequired();

            builder.PropertyWithUnderscore(x => x.ReferenceId).IsRequired();

            // Внешние ключи
            builder.HasOne(p => p.Facility)
                .WithMany()
                .HasForeignKey(p => p.FacilityId)
                .OnDelete(DeleteBehavior.NoAction);

            builder.HasOne(p => p.Product)
                .WithMany()
                .HasForeignKey(p => p.ProductId)
                .OnDelete(DeleteBehavior.NoAction);

            // Индексы
            builder.HasIndexWithUnderscore(x => x.FacilityId);

            builder.HasIndexWithUnderscore(x => x.ProductId);

            builder.HasIndexWithUnderscore(x => x.OperationType);

            builder.HasIndexWithUnderscore(x => x.ReferenceType);

            builder.HasIndexWithUnderscore(x => x.ReferenceId);

            builder.HasIndexWithUnderscore(x => x.DateCreated);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\SupplierConfiguration.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Extentions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class SupplierConfiguration : IEntityTypeConfiguration<Supplier>
    {
        public void Configure(EntityTypeBuilder<Supplier> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(Supplier));

            builder.HasBaseEntityInt();


            builder.PropertyWithUnderscore(x => x.Name).IsRequired();
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\SupplyConfiguration.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Extentions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class SupplyConfiguration : IEntityTypeConfiguration<Supply>
    {
        public void Configure(EntityTypeBuilder<Supply> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(Supply));

            builder.HasBaseEntityGuid();
            builder.HasCreatedDateEntity();


            builder.PropertyWithUnderscore(x => x.PurchaseId).IsRequired();
            
            builder.PropertyWithUnderscore(x => x.Quantity).IsRequired();

            // Внешние ключи
            builder.HasOne(p => p.Purchase)
                .WithMany()
                .HasForeignKey(p => p.PurchaseId)
                .OnDelete(DeleteBehavior.NoAction);

            // Индексы
            builder.HasIndexWithUnderscore(x => x.PurchaseId);

            builder.HasIndexWithUnderscore(x => x.DateCreated);

        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\SystemLogConfiguration.cs
================================================================================

using CubArt.Domain.Entities;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Microsoft.EntityFrameworkCore;
using CubArt.Infrastructure.Extentions;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class SystemLogConfiguration : IEntityTypeConfiguration<SystemLog>
    {
        public void Configure(EntityTypeBuilder<SystemLog> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(SystemLog));
            builder.HasBaseEntityGuid();
            builder.HasCreatedDateEntity();

            builder.PropertyWithUnderscore(x => x.Level).HasMaxLength(20);
            builder.PropertyWithUnderscore(x => x.Message).HasColumnType(SqlColumnTypes.Text);
            builder.PropertyWithUnderscore(x => x.UserId).HasMaxLength(100);
            builder.PropertyWithUnderscore(x => x.IpAddress).HasMaxLength(50);
            builder.PropertyWithUnderscore(x => x.UserAgent).HasMaxLength(100);
            builder.PropertyWithUnderscore(x => x.RequestPath).HasMaxLength(1000);
            builder.PropertyWithUnderscore(x => x.RequestMethod).HasMaxLength(1000);
            builder.PropertyWithUnderscore(x => x.ExceptionType).HasMaxLength(1000);
            builder.PropertyWithUnderscore(x => x.Source).HasMaxLength(100);
            builder.PropertyWithUnderscore(x => x.Action).HasMaxLength(50);
            builder.PropertyWithUnderscore(x => x.EntityType).HasMaxLength(100);
            builder.PropertyWithUnderscore(x => x.EntityId).HasMaxLength(50);
            builder.PropertyWithUnderscore(x => x.AdditionalData).HasColumnType(SqlColumnTypes.JsonB);

            // Индексы
            builder.HasIndexWithUnderscore(x => x.Level);
            builder.HasIndexWithUnderscore(x => x.DateCreated);
            builder.HasIndexWithUnderscore(x => x.Source);
            builder.HasIndexWithUnderscore(x => x.UserId);
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\UserConfiguration.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Extentions;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class UserConfiguration : IEntityTypeConfiguration<User>
    {
        public void Configure(EntityTypeBuilder<User> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(User));

            builder.HasBaseEntityGuid();
            builder.HasCreatedDateEntity();

            builder.PropertyWithUnderscore(x => x.Username)
                .HasMaxLength(50)
                .IsRequired();

            builder.PropertyWithUnderscore(x => x.Email)
                .HasMaxLength(255)
                .IsRequired();

            builder.PropertyWithUnderscore(x => x.PasswordHash)
                .HasMaxLength(255)
                .IsRequired();

            builder.PropertyWithUnderscore(x => x.FirstName)
                .HasMaxLength(100);

            builder.PropertyWithUnderscore(x => x.LastName)
                .HasMaxLength(100);

            builder.PropertyWithUnderscore(x => x.IsActive);

            builder.PropertyWithUnderscore(x => x.LastLogin)
                .HasDateTimeConversion()
                .HasColumnType(SqlColumnTypes.TimeStampWithTimeZone);

            // Индексы
            builder.HasIndexWithUnderscore(x => x.Username).IsUnique();
            builder.HasIndexWithUnderscore(x => x.Email).IsUnique();
            builder.HasIndexWithUnderscore(x => x.IsActive);
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Data\Configurations\UserRoleConfiguration.cs
================================================================================

using CubArt.Domain.Entities;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Microsoft.EntityFrameworkCore;
using CubArt.Infrastructure.Extentions;

namespace CubArt.Infrastructure.Data.Configurations
{
    public class UserRoleConfiguration : IEntityTypeConfiguration<UserRole>
    {
        public void Configure(EntityTypeBuilder<UserRole> builder)
        {
            builder.HasTableNameUnderscoreStyle(nameof(UserRole));

            builder.HasBaseEntityInt();

            builder.PropertyWithUnderscore(x => x.UserId)
                .IsRequired();

            builder.PropertyWithUnderscore(x => x.RoleId)
                .IsRequired();

            // Внешние ключи
            builder.HasOne(ur => ur.User)
                .WithMany(u => u.UserRoles)
                .HasForeignKey(ur => ur.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            builder.HasOne(ur => ur.Role)
                .WithMany(r => r.UserRoles)
                .HasForeignKey(ur => ur.RoleId)
                .OnDelete(DeleteBehavior.Cascade);

            // Индексы
            builder.HasIndex(x => new { x.UserId, x.RoleId })
                .IsUnique();
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Extentions\PropertyBuilderExtensions.cs
================================================================================

using CubArt.Domain.Common;
using CubArt.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using System.Linq.Expressions;
using System.Text.RegularExpressions;

namespace CubArt.Infrastructure.Extentions
{
    internal static class PropertyBuilderExtensions
    {
        public static void HasCreatedDateEntity<T>(this EntityTypeBuilder<T> builder)
            where T : class, IHasCreatedDate
            => builder.PropertyWithUnderscore(x => x.DateCreated)
                .HasDateTimeConversion()
                .HasColumnType(SqlColumnTypes.TimeStampWithTimeZone)
                .HasDefaultValueSql("now() at time zone 'utc'");

        public static PropertyBuilder<DateTime> HasDateTimeConversion(this PropertyBuilder<DateTime> builder)
            => builder.HasConversion(
                v => v,
                v => v.ToUniversalTime());

        public static PropertyBuilder<DateTime?> HasDateTimeConversion(this PropertyBuilder<DateTime?> builder)
            => builder.HasConversion(
                v => v,
                v => v.HasValue ? v.Value.ToUniversalTime() : null);


        #region Naming Column and Table

        public static void HasBaseEntityInt<T>(this EntityTypeBuilder<T> builder)
            where T : Entity<int>
        {
            builder.HasKey(x => x.Id);
            builder.PropertyWithUnderscore(x => x.Id).HasColumnNameUnderscoreStyle(nameof(Entity<int>.Id));
        }

        public static void HasBaseEntityLong<T>(this EntityTypeBuilder<T> builder)
            where T : Entity<long>
        {
            builder.HasKey(x => x.Id);
            builder.PropertyWithUnderscore(x => x.Id).HasColumnNameUnderscoreStyle(nameof(Entity<long>.Id));
        }

        public static void HasBaseEntityGuid<T>(this EntityTypeBuilder<T> builder)
            where T : Entity<Guid>
        {
            builder.HasKey(x => x.Id);
            builder.PropertyWithUnderscore(x => x.Id).HasColumnNameUnderscoreStyle(nameof(Entity<Guid>.Id));
        }

        public static EntityTypeBuilder<T> HasTableNameUnderscoreStyle<T>(this EntityTypeBuilder<T> builder, string fieldName) where T : class
            => builder.ToTable(fieldName.ToLowerCaseWithUnderscore());

        public static EntityTypeBuilder<T> HasViewNameUnderscoreStyle<T>(this EntityTypeBuilder<T> builder, string fieldName) where T : class
            => builder.ToView(fieldName.ToLowerCaseWithUnderscore());

        public static PropertyBuilder<T> HasColumnNameUnderscoreStyle<T>(this PropertyBuilder<T> builder, string fieldName)
            => builder.HasColumnName(fieldName.ToLowerCaseWithUnderscore());

        public static string ToLowerCaseWithUnderscore(this string text) => Regex
            .Replace(text, "(?<=[^_])[A-Z]", result => '_' + result.ToString().ToLower())
            .ToLower(); // на всякий случай второе приведение для других символов из строки (для всех которые -> _A || Test || Ta)

        public static PropertyBuilder<TProperty> PropertyWithUnderscore<TEntity, TProperty>(
            this EntityTypeBuilder<TEntity> builder,
            Expression<Func<TEntity, TProperty>> propertyExpression) where TEntity : class =>
            builder
                .Property(propertyExpression)
                .HasColumnNameUnderscoreStyle(propertyExpression.GetMemberAccess().Name);

        public static IndexBuilder HasIndexWithUnderscore<TEntity, TProperty>(
        this EntityTypeBuilder<TEntity> builder,
        Expression<Func<TEntity, TProperty>> propertyExpression,
        string? customName = null) where TEntity : class
        {
            var propertyName = propertyExpression.GetMemberAccess().Name;
            var indexName = customName ?? $"idx_{typeof(TEntity).Name.ToLowerCaseWithUnderscore()}_{propertyName.ToLowerCaseWithUnderscore()}";

            // Преобразуем Expression<Func<TEntity, TProperty>> в Expression<Func<TEntity, object>>
            var convertedExpression = Expression.Lambda<Func<TEntity, object>>(
                Expression.Convert(propertyExpression.Body, typeof(object)),
                propertyExpression.Parameters
            );

            return builder.HasIndex(convertedExpression)
                .HasDatabaseName(indexName);
        }



        #endregion
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Extentions\SqlColumnTypes.cs
================================================================================

namespace CubArt.Infrastructure.Extentions
{
    public static class SqlColumnTypes
    {
        public const string Date = "date";
        public const string TimeStamp = "timestamp";
        public const string TimeStampWithTimeZone = "timestamp with time zone";
        public const string JsonB = "jsonb";
        public const string Json = "json";
        public const string Text = "text";
        public const string Xid = "xid";

        public static string Varchar(int length)
        {
            return $"varchar({length})";
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Interfaces\IDapperService.cs
================================================================================

namespace CubArt.Infrastructure.Interfaces
{
    public interface IDapperService
    {
        Task<IEnumerable<T>> QueryAsync<T>(string sql, object? parameters = null, int? commandTimeout = null);
        Task<T> QueryFirstOrDefaultAsync<T>(string sql, object? parameters = null, int? commandTimeout = null);
        Task<T> QuerySingleOrDefaultAsync<T>(string sql, object? parameters = null, int? commandTimeout = null);
        Task<int> ExecuteAsync(string sql, object? parameters = null, int? commandTimeout = null);
        Task<T> ExecuteScalarAsync<T>(string sql, object? parameters = null, int? commandTimeout = null);
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Interfaces\IPaymentRepository.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Common;

namespace CubArt.Infrastructure.Interfaces
{
    public interface IPaymentRepository : IRepository<Payment, Guid>
    {
        Task<decimal> GetTotalPaidAmountAsync(Guid purchaseId, Guid? paymentId = null);
        Task<IEnumerable<Payment>> GetPaymentsByPurchaseIdAsync(Guid purchaseId);
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Interfaces\IProductionRepository.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Common;

namespace CubArt.Infrastructure.Interfaces
{
    public interface IProductionRepository : IRepository<Production, Guid>
    {
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Interfaces\IProductRepository.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Common;

namespace CubArt.Infrastructure.Interfaces
{
    public interface IProductRepository : IRepository<Product, int>
    {
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Interfaces\IPurchaseRepository.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Common;

namespace CubArt.Infrastructure.Interfaces
{
    public interface IPurchaseRepository : IRepository<Purchase, Guid>
    {
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Interfaces\IStockMovementService.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Domain.Enums;
using CubArt.Infrastructure.Models;

namespace CubArt.Infrastructure.Interfaces
{
    public interface IStockMovementService
    {
        Task RecalculateAllBalancesFromDate(DateTime date, int? facilityId = null, int? productId = null, CancellationToken cancellationToken = default);

        Task<DateTime> GetLastBalanceDate();

        Task<List<StockMovement>> GetStockMovementsByReference(string referenceId, StockMovemetReferenceTypeEnum referenceType);

        Task<StockBalanceView> GetStockBalanceByDate(int? facilityId, int? productId, DateTime BalanceDate);

        Task UpdateStockMovementsAndRecalculateBalances(UpdateStockMovementsAndRecalculateBalancesModel model);

        Task DeleteStockMovements(Guid referenceId, StockMovemetReferenceTypeEnum referenceType);
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Interfaces\ISupplyRepository.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Common;

namespace CubArt.Infrastructure.Interfaces
{
    public interface ISupplyRepository : IRepository<Supply, Guid>
    {
        Task<decimal> GetTotalIncomeQuantityAsync(Guid purchaseId, Guid? sypplyId = null);
        Task<IEnumerable<Supply>> GetSuppliesByPurchaseIdAsync(Guid purchaseId);
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Interfaces\ISystemLogRepository.cs
================================================================================

using CubArt.Domain.Entities;

namespace CubArt.Infrastructure.Interfaces
{
    public interface ISystemLogRepository
    {
        Task AddAsync(SystemLog log);

        Task AddRangeAsync(IEnumerable<SystemLog> logs);
        Task CleanOldLogsAsync(DateTime olderThan, CancellationToken cancellationToken);
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Interfaces\IUserRepository.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Common;

namespace CubArt.Infrastructure.Interfaces
{
    public interface IUserRepository : IRepository<User, Guid>
    {
        Task<User?> GetByUsernameAsync(string username);
        Task<User?> GetByEmailAsync(string email);
        Task<bool> UsernameExistsAsync(string username);
        Task<bool> EmailExistsAsync(string email);
        Task<User?> GetByIdWithRolesAsync(Guid id);
        Task<User?> GetByUsernameWithRolesAsync(string username);
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Models\UpdateStockMovementsAndRecalculateBalancesModel.cs
================================================================================

using CubArt.Domain.Enums;

namespace CubArt.Infrastructure.Models
{
    public record UpdateStockMovementsAndRecalculateBalancesModel(
        Guid ReferenceId,
        OperationTypeEnum OperationType,
        StockMovemetReferenceTypeEnum ReferenceType, 
        DateTime Date, 
        int FacilityId, 
        int ProductId, 
        decimal Quantity
    );
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Repositories\PaymentRepository.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Domain.Enums;
using CubArt.Infrastructure.Common;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Infrastructure.Repositories
{
    public class PaymentRepository : Repository<Payment, Guid>, IPaymentRepository
    {
        public PaymentRepository(AppDbContext context) : base(context)
        {
        }

        public async Task<decimal> GetTotalPaidAmountAsync(Guid purchaseId, Guid? paymentId = null)
        {
            return await _dbSet
                .Where(p => p.PurchaseId == purchaseId && p.PaymentStatus == PaymentStatusEnum.Completed &&
                    (paymentId == null || p.Id != paymentId))
                .SumAsync(p => p.Amount);
        }

        public async Task<IEnumerable<Payment>> GetPaymentsByPurchaseIdAsync(Guid purchaseId)
        {
            return await _dbSet
                .Where(p => p.PurchaseId == purchaseId)
                .OrderByDescending(p => p.DateCreated)
                .AsNoTracking()
                .ToListAsync();
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Repositories\ProductionRepository.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Infrastructure.Repositories
{
    public class ProductionRepository : IProductionRepository
    {
        private readonly AppDbContext _context;

        public ProductionRepository(AppDbContext context)
        {
            _context = context;
        }

        public IQueryable<Production> GetQueryable()
        {
            return _context.Productions
                .AsNoTracking()
                .AsQueryable();
        }

        public async Task<Production?> GetByIdAsync(Guid id, bool includeRelated = false)
        {
            if (includeRelated)
            {
                return await _context.Productions
                    .Include(x => x.Facility)
                    .Include(x => x.Product)
                    .AsNoTracking()
                    .FirstOrDefaultAsync(x => x.Id == id);
            }
            else
            {
                return await _context.Productions
                    .AsNoTracking()
                    .FirstOrDefaultAsync(x => x.Id == id);
            }
        }

        public async Task AddAsync(Production entity) =>
            await _context.Productions.AddAsync(entity);

        public void Update(Production entity) =>
            _context.Productions.Update(entity);

        public void Delete(Production entity) =>
            _context.Productions.Remove(entity);
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Repositories\ProductRepository.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Common;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Infrastructure.Repositories
{
    public class ProductRepository : Repository<Product, int>, IProductRepository
    {
        public ProductRepository(AppDbContext context) : base(context)
        {
        }

        public override async Task<Product?> GetByIdAsync(int id, bool includeRelated = false)
        {
            if (includeRelated)
            {
                return await _dbSet
                    .Include(p => p.ProductSpecifications)
                    .ThenInclude(ps => ps.Items)
                    .ThenInclude(psi => psi.Product)
                    .AsNoTracking()
                    .FirstOrDefaultAsync(p => p.Id == id);
            }

            return await base.GetByIdAsync(id, includeRelated);
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Repositories\PurchaseRepository.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Infrastructure.Repositories
{
    public class PurchaseRepository : IPurchaseRepository
    {
        private readonly AppDbContext _context;

        public PurchaseRepository(AppDbContext context)
        {
            _context = context;
        }

        public IQueryable<Purchase> GetQueryable()
        {
            return _context.Purchases
                .AsNoTracking()
                .AsQueryable();
        }

        public async Task<Purchase?> GetByIdAsync(Guid id, bool includeRelated = false)
        {
            if (includeRelated)
            {
                return await _context.Purchases
                    .Include(x => x.Facility)
                    .Include(x => x.Supplier)
                    .Include(x => x.Product)
                    .AsNoTracking()
                    .FirstOrDefaultAsync(x => x.Id == id);
            }
            else
            {
                return await _context.Purchases
                    .AsNoTracking()
                    .FirstOrDefaultAsync(x => x.Id == id);
            }
        }

        public async Task AddAsync(Purchase entity) =>
            await _context.Purchases.AddAsync(entity);

        public void Update(Purchase entity) =>
            _context.Purchases.Update(entity);

        public void Delete(Purchase entity) =>
            _context.Purchases.Remove(entity);
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Repositories\SupplyRepository.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Common;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Infrastructure.Repositories
{
    public class SupplyRepository : Repository<Supply, Guid>, ISupplyRepository
    {
        public SupplyRepository(AppDbContext context) : base(context)
        {
        }

        public async Task<decimal> GetTotalIncomeQuantityAsync(Guid purchaseId, Guid? supplyId = null)
        {
            return await _dbSet
                .Where(p => p.PurchaseId == purchaseId &&
                    (supplyId == null || p.Id != supplyId))
                .SumAsync(p => p.Quantity);
        }

        public async Task<IEnumerable<Supply>> GetSuppliesByPurchaseIdAsync(Guid purchaseId)
        {
            return await _dbSet
                .Where(p => p.PurchaseId == purchaseId)
                .OrderByDescending(p => p.DateCreated)
                .AsNoTracking()
                .ToListAsync();
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Repositories\SystemLogRepository.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Infrastructure.Repositories
{
    public class SystemLogRepository : ISystemLogRepository
    {
        private readonly LogDbContext _context;

        public SystemLogRepository(LogDbContext context)
        {
            _context = context;
        }

        public async Task AddAsync(SystemLog log)
        {
            await _context.SystemLogs.AddAsync(log);
            await _context.SaveChangesAsync();
        }

        public async Task AddRangeAsync(IEnumerable<SystemLog> logs)
        {
            await _context.SystemLogs.AddRangeAsync(logs);
            await _context.SaveChangesAsync();
        }

        public async Task CleanOldLogsAsync(DateTime olderThan, CancellationToken cancellationToken)
        {
            var logsToDelete = await _context.SystemLogs
                .Where(x => x.DateCreated < olderThan)
                .AsNoTracking()
                .ToListAsync(cancellationToken);

            _context.SystemLogs.RemoveRange(logsToDelete);
            await _context.SaveChangesAsync(cancellationToken);
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Repositories\UserRepository.cs
================================================================================

using CubArt.Domain.Entities;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using Microsoft.EntityFrameworkCore;

namespace CubArt.Infrastructure.Repositories
{
    public class UserRepository : IUserRepository
    {
        private readonly AppDbContext _context;

        public UserRepository(AppDbContext context)
        {
            _context = context;
        }

        public IQueryable<User> GetQueryable()
        {
            return _context.Users.AsNoTracking().AsQueryable();
        }

        public async Task<User?> GetByIdAsync(Guid id, bool includeRelated = false)
        {
            return await _context.Users
                .AsNoTracking()
                .FirstOrDefaultAsync(u => u.Id == id);
        }

        public async Task<User?> GetByUsernameAsync(string username)
        {
            return await _context.Users
                .AsNoTracking()
                .FirstOrDefaultAsync(u => u.Username == username);
        }

        public async Task<User?> GetByEmailAsync(string email)
        {
            return await _context.Users
                .AsNoTracking()
                .FirstOrDefaultAsync(u => u.Email == email);
        }

        public async Task<bool> UsernameExistsAsync(string username)
        {
            return await _context.Users
                .AnyAsync(u => u.Username == username);
        }

        public async Task<bool> EmailExistsAsync(string email)
        {
            return await _context.Users
                .AnyAsync(u => u.Email == email);
        }

        public async Task AddAsync(User entity)
        {
            await _context.Users.AddAsync(entity);
        }

        public void Update(User entity)
        {
            _context.Users.Update(entity);
        }

        public void Delete(User entity)
        {
            _context.Users.Remove(entity);
        }

        public async Task<User?> GetByIdWithRolesAsync(Guid id)
        {
            return await _context.Users
                .Include(u => u.UserRoles)
                    .ThenInclude(ur => ur.Role)
                        .ThenInclude(r => r.RolePermissions)
                .AsNoTracking()
                .FirstOrDefaultAsync(u => u.Id == id);
        }

        public async Task<User?> GetByUsernameWithRolesAsync(string username)
        {
            return await _context.Users
                .Include(u => u.UserRoles)
                    .ThenInclude(ur => ur.Role)
                        .ThenInclude(r => r.RolePermissions)
                .AsNoTracking()
                .FirstOrDefaultAsync(u => u.Username == username);
        }
    }
}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Services\DapperService.cs
================================================================================

using CubArt.Infrastructure.Interfaces;
using Dapper;
using Microsoft.Extensions.Configuration;
using Npgsql;
using System.Data;

namespace CubArt.Infrastructure.Services
{
    public class DapperService : IDapperService
    {
        private readonly string _connectionString;

        public DapperService(IConfiguration configuration)
        {
            _connectionString = configuration.GetConnectionString("DBConnectionString");
        }

        private IDbConnection CreateConnection()
        {
            return new NpgsqlConnection(_connectionString);
        }

        public async Task<IEnumerable<T>> QueryAsync<T>(string sql, object? parameters = null, int? commandTimeout = null)
        {
            using var connection = CreateConnection();
            return await connection.QueryAsync<T>(sql, parameters, commandTimeout: commandTimeout);
        }

        public async Task<T> QueryFirstOrDefaultAsync<T>(string sql, object? parameters = null, int? commandTimeout = null)
        {
            using var connection = CreateConnection();
            return await connection.QueryFirstOrDefaultAsync<T>(sql, parameters, commandTimeout: commandTimeout);
        }

        public async Task<T> QuerySingleOrDefaultAsync<T>(string sql, object? parameters = null, int? commandTimeout = null)
        {
            using var connection = CreateConnection();
            return await connection.QuerySingleOrDefaultAsync<T>(sql, parameters, commandTimeout: commandTimeout);
        }

        public async Task<int> ExecuteAsync(string sql, object? parameters = null, int? commandTimeout = null)
        {
            using var connection = CreateConnection();
            return await connection.ExecuteAsync(sql, parameters, commandTimeout: commandTimeout);
        }

        public async Task<T> ExecuteScalarAsync<T>(string sql, object? parameters = null, int? commandTimeout = null)
        {
            using var connection = CreateConnection();
            return await connection.ExecuteScalarAsync<T>(sql, parameters, commandTimeout: commandTimeout);
        }
    }

}

================================================================================
FILE: C:\Git\CubArt\CubArt.Infrastructure\Services\StockMovementService.cs
================================================================================

using CubArt.Domain.Common;
using CubArt.Domain.Entities;
using CubArt.Domain.Enums;
using CubArt.Infrastructure.Common;
using CubArt.Infrastructure.Data;
using CubArt.Infrastructure.Interfaces;
using CubArt.Infrastructure.Models;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;

namespace CubArt.Infrastructure.Services
{
    public class StockMovementService : IStockMovementService
    {
        private readonly IRepository<StockMovement, Guid> _movementRepository;
        private readonly IRepository<StockBalance, Guid> _balanceRepository;
        private readonly AppDbContext _appDbContext;
        private readonly IDapperService _dapperService;
        private readonly IUnitOfWork _unitOfWork;
        private readonly ILogger<StockMovementService> _logger;

        public StockMovementService(
            IRepository<StockMovement, Guid> movementRepository,
            IRepository<StockBalance, Guid> balanceRepository,
            AppDbContext appDbContext,
            IDapperService dapperService,
            ILogger<StockMovementService> logger,
            IUnitOfWork unitOfWork)
        {
            _movementRepository = movementRepository;
            _balanceRepository = balanceRepository;
            _appDbContext = appDbContext;
            _dapperService = dapperService;
            _logger = logger;
            _unitOfWork = unitOfWork;
        }

        public async Task<List<StockMovement>> GetStockMovementsByReference(string referenceId, StockMovemetReferenceTypeEnum referenceType)
        {
            var ers = await _movementRepository.GetQueryable()
                .Include(m => m.Facility)
                .Include(m => m.Product)
                .Where(m => m.ReferenceId == referenceId &&
                           m.ReferenceType == referenceType)
                .OrderBy(m => m.DateCreated)
                .ToListAsync();

            return ers;
        }

        public async Task RecalculateAllBalancesFromDate(DateTime date, int? facilityId = null, int? productId = null, CancellationToken cancellationToken = default)
        {
            while (date.Date < DateTime.UtcNow.Date || cancellationToken.IsCancellationRequested)
            {
                await RecalculateAllBalancesForDate(date, facilityId, productId, cancellationToken);
                _logger.LogInformation("Балансы пересчитаны за {Date}", date.ToString("yyyy-MM-dd"));

                date = date.AddDays(1).Date;
            }
        }

        public async Task<DateTime> GetLastBalanceDate()
        {
            var lastBalanceDate = await _balanceRepository.GetQueryable()
                .OrderByDescending(b => b.DateCreated)
                .Select(b => b.DateCreated.Date)
                .FirstOrDefaultAsync();

            var today = DateTime.UtcNow.Date;
            return lastBalanceDate == default ? today.AddDays(-7) : lastBalanceDate.AddDays(1);
        }

        public async Task<StockBalanceView> GetStockBalanceByDate(int? facilityId, int? productId, DateTime balanceDate)
        {
            var sql = $@"
                    WITH last_balances AS (
                        SELECT DISTINCT ON (facility_id, product_id) 
                            facility_id, 
                            product_id, 
                            finish_balance
                        FROM stock_balance 
                        WHERE date_created < @balanceDate
                        ORDER BY facility_id, product_id, date_created DESC
                    ),
                    day_movements AS (
                        SELECT 
                            facility_id,
                            product_id,
                            COALESCE(SUM(CASE WHEN operation_type = 1 THEN quantity ELSE 0 END), 0) as income,
                            COALESCE(SUM(CASE WHEN operation_type = 2 THEN quantity ELSE 0 END), 0) as outcome
                        FROM stock_movement 
                        WHERE DATE(date_created) = DATE(@balanceDate)
                        GROUP BY facility_id, product_id
                    )
                    SELECT 
                        f.name as FacilityName,
                        p.name as ProductName,
                        p.product_type as ProductType,
                        p.unit_of_measure as UnitOfMeasure,
                        COALESCE(lb.finish_balance, 0) as StartBalance,
                        COALESCE(dm.income, 0) as IncomeBalance,
                        COALESCE(dm.outcome, 0) as OutcomeBalance,
                        COALESCE(lb.finish_balance, 0) + COALESCE(dm.income, 0) - COALESCE(dm.outcome, 0) as FinishBalance,
                        DATE(@balanceDate) as BalanceDate
                    FROM facility f
                    CROSS JOIN product p
                    LEFT JOIN last_balances lb ON lb.facility_id = f.id AND lb.product_id = p.id
                    LEFT JOIN day_movements dm ON dm.facility_id = f.id AND dm.product_id = p.id
                    WHERE 
                      (@facilityId IS NULL OR f.id = @facilityId) AND
                      (@productId IS NULL OR p.id = @productId) AND
                      (COALESCE(lb.finish_balance, 0) != 0 OR COALESCE(dm.income, 0) != 0 OR COALESCE(dm.outcome, 0) != 0)";

            // Создаем параметры
            var parameters = new
            {
                balanceDate = balanceDate.Date,
                facilityId = facilityId,
                productId = productId
            };

            // Получаем данные 
            return await _dapperService.QueryFirstOrDefaultAsync<StockBalanceView>(sql, parameters);
        }

        public async Task UpdateStockMovementsAndRecalculateBalances(UpdateStockMovementsAndRecalculateBalancesModel model)
        {
            var movements = await GetStockMovementsByReference(model.ReferenceId.ToString(), model.ReferenceType);
            foreach (var movement in movements)
            {                
                movement.UpdateEntity(
                    model.FacilityId,
                    model.ProductId,
                    model.OperationType,
                    model.ReferenceType,
                    model.ReferenceId.ToString(),
                    model.Quantity,
                    model.Date
                );
                _movementRepository.Update(movement);
            }
            await _unitOfWork.CommitAsync();
            await RecalculateAllBalancesFromDate(model.Date.Date, model.FacilityId, model.ProductId);
        }

        public async Task DeleteStockMovements(Guid referenceId, StockMovemetReferenceTypeEnum referenceType)
        {
            var movements = await GetStockMovementsByReference(referenceId.ToString(), referenceType);
            foreach (var movement in movements)
            {
                var entity = await _movementRepository.GetByIdAsync(movement.Id);
                _movementRepository.Delete(entity);
            }
            await _unitOfWork.CommitAsync();
        }

        #region Private methods

        private async Task RecalculateAllBalancesForDate(DateTime date, int? facilityId = null, int? productId = null, CancellationToken cancellationToken = default)
        {
            // Получаем все уникальные комбинации facilityId + productId за текущую дату
            var movementCombinations = await _movementRepository.GetQueryable()
                .Where(m => m.DateCreated.Date == date.Date &&
                    (facilityId == null || m.FacilityId == facilityId) &&
                    (productId == null || m.ProductId == productId))
                .Select(m => new { m.FacilityId, m.ProductId })
                .Distinct()
                .ToListAsync(cancellationToken);

            var balanceCombinations = await _balanceRepository.GetQueryable()
                .Where(m => m.DateCreated.Date == date.Date &&
                    (facilityId == null || m.FacilityId == facilityId) &&
                    (productId == null || m.ProductId == productId))
                .Select(m => new { m.Id, m.FacilityId, m.ProductId })
                .Distinct()
                .ToListAsync(cancellationToken);

            foreach (var combo in balanceCombinations)
            {
                if (!movementCombinations.Any(x => x.FacilityId == combo.FacilityId && x.ProductId == combo.ProductId))
                {
                    var entity = await _balanceRepository.GetByIdAsync(combo.Id);
                    _balanceRepository.Delete(entity);
                }
            }
            await _unitOfWork.CommitAsync();

            foreach (var combo in movementCombinations)
            {
                await RecalculateBalance(combo.FacilityId, combo.ProductId, date, cancellationToken);
            }
        }

        private async Task RecalculateBalance(int facilityId, int productId, DateTime date,
            CancellationToken cancellationToken = default)
        {
            // Получаем все движения за указанную дату
            var movements = await _movementRepository.GetQueryable()
                .Where(m => m.FacilityId == facilityId &&
                           m.ProductId == productId &&
                           m.DateCreated.Date == date.Date)
                .OrderBy(m => m.DateCreated)
                .ToListAsync(cancellationToken);

            if (!movements.Any()) return;

            // Находим последний баланс перед началом периода
            var lastBalance = await _balanceRepository.GetQueryable()
                .Where(b => b.FacilityId == facilityId &&
                           b.ProductId == productId &&
                           b.DateCreated < date.Date)
                .OrderByDescending(b => b.DateCreated)
                .FirstOrDefaultAsync(cancellationToken);

            decimal startBalance = lastBalance?.FinishBalance ?? 0;
            decimal income = 0;
            decimal outcome = 0;

            foreach (var movement in movements)
            {
                if (movement.OperationType == OperationTypeEnum.Income)
                    income += movement.Quantity;
                else
                    outcome += movement.Quantity;
            }

            decimal finishBalance = startBalance + income - outcome;

            // Создаем или обновляем баланс
            var existingBalance = await _balanceRepository
                .GetQueryable()
                .FirstOrDefaultAsync(b => b.FacilityId == facilityId &&
                                        b.ProductId == productId &&
                                        b.DateCreated.Date == date.Date,
                                    cancellationToken);

            if (existingBalance != null)
            {
                existingBalance.UpdateBalances(startBalance, income, outcome, finishBalance);
                _balanceRepository.Update(existingBalance);
            }
            else
            {
                var balance = new StockBalance(
                    facilityId, productId, startBalance, income, outcome, finishBalance, date.Date);
                await _balanceRepository.AddAsync(balance);
            }

            await _unitOfWork.CommitAsync(cancellationToken);
        }
        #endregion
    }
}
